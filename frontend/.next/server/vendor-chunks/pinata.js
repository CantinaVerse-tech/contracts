"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pinata";
exports.ids = ["vendor-chunks/pinata"];
exports.modules = {

/***/ "(rsc)/./node_modules/pinata/dist/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/pinata/dist/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PinataSDK: () => (/* binding */ PinataSDK)\n/* harmony export */ });\n// src/utils/custom-errors.ts\nvar PinataError = class extends Error {\n  constructor(message, statusCode, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.details = details;\n    this.name = \"PinataError\";\n  }\n};\nvar NetworkError = class extends PinataError {\n  constructor(message, statusCode, details) {\n    super(message, statusCode, details);\n    this.name = \"NetworkError\";\n  }\n};\nvar AuthenticationError = class extends PinataError {\n  constructor(message, statusCode, details) {\n    super(message, statusCode, details);\n    this.name = \"AuthenticationError\";\n  }\n};\nvar ValidationError = class extends PinataError {\n  constructor(message, details) {\n    super(message, void 0, details);\n    this.name = \"ValidationError\";\n  }\n};\n\n// src/core/authentication/testAuthentication.ts\nvar testAuthentication = async (config) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      Source: \"sdk/testAuthentication\"\n    };\n  }\n  try {\n    const request = await fetch(`${endpoint}/data/testAuthentication`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing authentication: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while testing authentication\"\n    );\n  }\n};\n\n// src/core/pinning/file.ts\nvar uploadFile = async (config, file, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config.pinataJwt;\n  const data = new FormData();\n  data.append(\"file\", file, file.name);\n  data.append(\n    \"pinataOptions\",\n    JSON.stringify({\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    })\n  );\n  data.append(\n    \"pinataMetadata\",\n    JSON.stringify({\n      name: options?.metadata?.name || file.name || \"File from SDK\",\n      keyvalues: options?.metadata?.keyValues\n    })\n  );\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      Source: \"sdk/file\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error uploading file: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading the file\");\n  }\n};\n\n// src/core/pinning/fileArray.ts\nvar uploadFileArray = async (config, files, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const folder = options?.metadata?.name || \"folder_from_sdk\";\n  const data = new FormData();\n  for (const file of Array.from(files)) {\n    data.append(\"file\", file, `${folder}/${file.name}`);\n  }\n  data.append(\n    \"pinataMetadata\",\n    JSON.stringify({\n      name: folder,\n      keyvalues: options?.metadata?.keyValues\n    })\n  );\n  data.append(\n    \"pinataOptions\",\n    JSON.stringify({\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    })\n  );\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      Source: \"sdk/fileArray\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing fileArray: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while uploading an array of files\"\n    );\n  }\n};\n\n// src/core/pinning/base64.ts\nvar uploadBase64 = async (config, base64String, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const name = options?.metadata?.name ? options?.metadata?.name : \"base64 string\";\n  const buffer = Buffer.from(base64String, \"base64\");\n  const blob = new Blob([buffer]);\n  const data = new FormData();\n  data.append(\"file\", blob, name);\n  data.append(\n    \"pinataOptions\",\n    JSON.stringify({\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    })\n  );\n  data.append(\n    \"pinataMetadata\",\n    JSON.stringify({\n      name,\n      keyvalues: options?.metadata?.keyValues\n    })\n  );\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      Source: \"sdk/base64\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing base64: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while trying to upload base64\"\n    );\n  }\n};\n\n// src/core/pinning/url.ts\nvar uploadUrl = async (config, url, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const data = new FormData();\n  const stream = await fetch(url);\n  if (!stream.ok) {\n    const errorData = await stream.text();\n    throw new NetworkError(\n      `HTTP error: ${errorData}`,\n      stream.status,\n      errorData\n    );\n  }\n  const arrayBuffer = await stream.arrayBuffer();\n  const blob = new Blob([arrayBuffer]);\n  const name = options?.metadata?.name ?? \"url_upload\";\n  const file = new File([blob], name);\n  data.append(\"file\", file, name);\n  data.append(\n    \"pinataOptions\",\n    JSON.stringify({\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    })\n  );\n  data.append(\n    \"pinataMetadata\",\n    JSON.stringify({\n      name,\n      keyvalues: options?.metadata?.keyValues\n    })\n  );\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      Source: \"sdk/url\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing url: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading by url\");\n  }\n};\n\n// src/core/pinning/json.ts\nvar uploadJson = async (config, jsonData, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const data = JSON.stringify({\n    pinataContent: jsonData,\n    pinataOptions: {\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    },\n    pinataMetadata: {\n      name: options?.metadata?.name || \"json\",\n      keyvalues: options?.metadata?.keyValues\n    }\n  });\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/json\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinJSONToIPFS`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing json: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading json\");\n  }\n};\n\n// src/core/pinning/cid.ts\nvar uploadCid = async (config, cid, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${jwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/cid\"\n    };\n  }\n  const data = JSON.stringify({\n    hashToPin: cid,\n    pinataMetadata: {\n      name: options?.metadata ? options?.metadata?.name : cid,\n      keyvalues: options?.metadata?.keyValues\n    },\n    pinataOptions: {\n      hostNodes: options?.peerAddresses ? options.peerAddresses : \"\",\n      groupId: options?.groupId\n    }\n  });\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/pinByHash`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing cid: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while pinning by CID\");\n  }\n};\n\n// src/core/pinning/unpin.ts\nvar wait = (milliseconds) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\nvar unpinFile = async (config, files) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const responses = [];\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      Source: \"sdk/unpin\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  for (const hash of files) {\n    try {\n      const response = await fetch(`${endpoint}/pinning/unpin/${hash}`, {\n        method: \"DELETE\",\n        headers\n      });\n      await wait(300);\n      if (!response.ok) {\n        const errorData = await response.text();\n        if (response.status === 401) {\n          throw new AuthenticationError(\n            `Authentication failed: ${errorData}`,\n            response.status,\n            errorData\n          );\n        }\n        throw new NetworkError(\n          `HTTP error: ${errorData}`,\n          response.status,\n          errorData\n        );\n      }\n      const result = await response.text();\n      responses.push({\n        hash,\n        status: result\n      });\n    } catch (error) {\n      let errorMessage;\n      if (error instanceof PinataError) {\n        errorMessage = error.message;\n      } else if (error instanceof Error) {\n        errorMessage = `Error unpinning file ${hash}: ${error.message}`;\n      } else {\n        errorMessage = `An unknown error occurred while unpinning file ${hash}`;\n      }\n      responses.push({\n        hash,\n        status: errorMessage\n      });\n    }\n  }\n  return responses;\n};\n\n// src/core/data/listFiles.ts\nvar listFiles = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const params = new URLSearchParams({\n    includesCount: \"false\"\n  });\n  if (options) {\n    const {\n      cid,\n      pinStart,\n      pinEnd,\n      pinSizeMin,\n      pinSizeMax,\n      pageLimit,\n      pageOffset,\n      name,\n      key,\n      value,\n      operator,\n      groupId\n    } = options;\n    if (cid)\n      params.append(\"cid\", cid);\n    if (pinStart)\n      params.append(\"pinStart\", pinStart);\n    if (pinEnd)\n      params.append(\"pinEnd\", pinEnd);\n    if (pinSizeMin)\n      params.append(\"pinSizeMin\", pinSizeMin.toString());\n    if (pinSizeMax)\n      params.append(\"pinSizeMax\", pinSizeMax.toString());\n    if (pageLimit)\n      params.append(\"pageLimit\", pageLimit.toString());\n    if (pageOffset)\n      params.append(\"pageOffset\", pageOffset.toString());\n    if (groupId)\n      params.append(\"groupId\", groupId);\n    if (name)\n      params.append(\"metadata[name]\", name);\n    if (key && value) {\n      const keyValueParam = JSON.stringify({\n        [key]: { value, op: operator || \"eq\" }\n      });\n      params.append(\"metadata[keyvalues]\", keyValueParam);\n    }\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  const url = `${endpoint}/data/pinList?status=pinned&${params.toString()}`;\n  try {\n    let headers;\n    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n      headers = { ...config.customHeaders };\n    } else {\n      headers = {\n        Authorization: `Bearer ${config.pinataJwt}`,\n        Source: \"sdk/listFiles\"\n      };\n    }\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.rows;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing list files: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing files\");\n  }\n};\n\n// src/core/data/updateMetadata.ts\nvar updateMetadata = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = {\n    ipfsPinHash: options.cid,\n    name: options.name,\n    keyvalues: options.keyValues\n  };\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/updateMetadata\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/pinning/hashMetadata`, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(data)\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing updateMetadata: ${error.message}`\n      );\n    }\n    throw new PinataError(\"An unknown error occurred while updating metadata\");\n  }\n};\n\n// src/utils/gateway-tools.ts\nvar isIPFSModule;\nasync function getIsIPFS() {\n  if (!isIPFSModule) {\n    isIPFSModule = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/is-ipfs\"), __webpack_require__.e(\"vendor-chunks/@multiformats\"), __webpack_require__.e(\"vendor-chunks/@chainsafe\"), __webpack_require__.e(\"vendor-chunks/uint8-varint\"), __webpack_require__.e(\"vendor-chunks/iso-url\"), __webpack_require__.e(\"vendor-chunks/@libp2p\")]).then(__webpack_require__.bind(__webpack_require__, /*! is-ipfs */ \"(rsc)/./node_modules/is-ipfs/dist/src/index.js\"));\n  }\n  return isIPFSModule;\n}\nasync function containsCID(input) {\n  if (typeof input !== \"string\") {\n    throw new Error(\"Input is not a string\");\n  }\n  const isIPFS = await getIsIPFS();\n  const startsWithCID = (str) => {\n    const parts = str.split(\"/\");\n    return isIPFS.cid(parts[0]) ? parts[0] : null;\n  };\n  const directCID = startsWithCID(input);\n  if (directCID) {\n    return {\n      containsCid: true,\n      cid: directCID\n    };\n  }\n  let url;\n  try {\n    url = new URL(input);\n  } catch (error) {\n    const parts = input.split(/\\/|\\?/);\n    for (const part of parts) {\n      const cid = startsWithCID(part);\n      if (cid) {\n        return {\n          containsCid: true,\n          cid\n        };\n      }\n    }\n    return {\n      containsCid: false,\n      cid: null\n    };\n  }\n  const subdomains = url.hostname.split(\".\");\n  for (const subdomain of subdomains) {\n    if (isIPFS.cid(subdomain)) {\n      return {\n        containsCid: true,\n        cid: subdomain\n      };\n    }\n  }\n  const pathParts = url.pathname.split(\"/\");\n  for (const part of pathParts) {\n    const cid = startsWithCID(part);\n    if (cid) {\n      return {\n        containsCid: true,\n        cid\n      };\n    }\n  }\n  return {\n    containsCid: false,\n    cid: null\n  };\n}\nasync function convertToDesiredGateway(sourceUrl, desiredGatewayPrefix) {\n  const results = await containsCID(sourceUrl);\n  if (results.containsCid !== true) {\n    throw new Error(\"url does not contain CID\");\n  }\n  if (!sourceUrl.startsWith(\"https\") && !sourceUrl.startsWith(\"ipfs://\")) {\n    return `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;\n  }\n  const urlObj = new URL(sourceUrl);\n  const path = urlObj.pathname + urlObj.search + urlObj.hash;\n  if (sourceUrl.startsWith(`ipfs://${results.cid}`)) {\n    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n  }\n  if (sourceUrl.includes(`/ipfs/${results.cid}`)) {\n    return `${desiredGatewayPrefix}${path}`;\n  }\n  if (sourceUrl.includes(`/ipns/${results.cid}`)) {\n    return `${desiredGatewayPrefix}${path}`;\n  }\n  if (urlObj.hostname.includes(results.cid)) {\n    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n  }\n  throw new Error(\n    \"unsupported URL pattern, please submit a github issue with the URL utilized\"\n  );\n}\n\n// src/core/gateway/getCid.ts\nvar getCid = async (config, cid) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let data;\n  let newUrl;\n  newUrl = await convertToDesiredGateway(cid, config?.pinataGateway);\n  if (config?.pinataGatewayKey) {\n    newUrl = `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n  }\n  try {\n    const request = await fetch(newUrl);\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication Failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const contentType = request.headers.get(\"content-type\");\n    if (contentType?.includes(\"application/json\")) {\n      data = await request.json();\n    } else if (contentType?.includes(\"text/\")) {\n      data = await request.text();\n    } else {\n      data = await request.blob();\n    }\n    const res = {\n      data,\n      contentType\n    };\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getCid: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while getting CID contents\"\n    );\n  }\n};\n\n// src/core/gateway/convertIPFSUrl.ts\nvar convertIPFSUrl = async (config, url) => {\n  let newUrl;\n  newUrl = await convertToDesiredGateway(url, config?.pinataGateway);\n  if (config?.pinataGatewayKey) {\n    `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n  }\n  return newUrl;\n};\n\n// src/core/data/pinJobs.ts\nvar pinJobs = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const params = new URLSearchParams({\n    includesCount: \"false\"\n  });\n  if (options) {\n    const { ipfs_pin_hash: cid, status, sort, limit, offset } = options;\n    if (cid)\n      params.append(\"ipfs_pin_hash\", cid.toString());\n    if (status)\n      params.append(\"status\", status.toString());\n    if (sort)\n      params.append(\"sort\", sort.toString());\n    if (limit)\n      params.append(\"limit\", limit.toString());\n    if (offset)\n      params.append(\"offset\", offset.toString());\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  const url = `${endpoint}/pinning/pinJobs?${params.toString()}`;\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      Source: \"sdk/pinJobs\"\n    };\n  }\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.rows;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing pinJobs: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing pin jobs\");\n  }\n};\n\n// src/core/data/pinnedFileUsage.ts\nvar pinnedFileCount = async (config) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      Source: \"sdk/pinnedFileUsage\"\n    };\n  }\n  try {\n    const request = await fetch(`${endpoint}/data/userPinnedDataTotal`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.pin_count;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing pinnedFileUsage: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while getting pinned file usage\"\n    );\n  }\n};\n\n// src/core/data/totalStorageUsage.ts\nvar totalStorageUsage = async (config) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      Source: \"sdk/totalStorageUsage\"\n    };\n  }\n  try {\n    const request = await fetch(`${endpoint}/data/userPinnedDataTotal`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.pin_size_total;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing totalStorageUsage: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while getting total storage usage\"\n    );\n  }\n};\n\n// src/core/keys/createKey.ts\nvar createKey = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/createKey\"\n    };\n  }\n  const data = JSON.stringify(options);\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/v3/pinata/keys`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing createKey: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while creating API key\");\n  }\n};\n\n// src/core/keys/listKeys.ts\nvar listKeys = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/listKeys\"\n    };\n  }\n  const params = new URLSearchParams();\n  if (options) {\n    const { offset, name, revoked, limitedUse, exhausted } = options;\n    if (offset)\n      params.append(\"offset\", offset.toString());\n    if (revoked !== void 0)\n      params.append(\"revoked\", revoked.toString());\n    if (limitedUse !== void 0)\n      params.append(\"limitedUse\", limitedUse.toString());\n    if (exhausted !== void 0)\n      params.append(\"exhausted\", exhausted.toString());\n    if (name)\n      params.append(\"name\", name);\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(\n      `${endpoint}/v3/pinata/keys?${params.toString()}`,\n      {\n        method: \"GET\",\n        headers\n      }\n    );\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.keys;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing listKeys: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing API keys\");\n  }\n};\n\n// src/core/keys/revokeKeys.ts\nvar wait2 = (milliseconds) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\nvar revokeKeys = async (config, keys) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/revokeKeys\"\n    };\n  }\n  const responses = [];\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  for (const key of keys) {\n    try {\n      const request = await fetch(`${endpoint}/v3/pinata/keys/${key}`, {\n        method: \"PUT\",\n        headers\n      });\n      await wait2(300);\n      if (!request.ok) {\n        const errorData = await request.text();\n        if (request.status === 401 || request.status === 403) {\n          throw new AuthenticationError(\n            `Authentication failed: ${errorData}`,\n            request.status,\n            errorData\n          );\n        }\n        throw new NetworkError(\n          `HTTP error: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      const result = await request.json();\n      responses.push({\n        key,\n        status: result\n      });\n    } catch (error) {\n      let errorMessage;\n      if (error instanceof PinataError) {\n        errorMessage = error.message;\n      } else if (error instanceof Error) {\n        errorMessage = `Error revoking key ${key}: ${error.message}`;\n      } else {\n        errorMessage = `An unknown error occurred while revoking key ${key}`;\n      }\n      responses.push({\n        key,\n        status: errorMessage\n      });\n    }\n  }\n  return responses;\n};\n\n// src/core/groups/createGroup.ts\nvar createGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = JSON.stringify(options);\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/createGroup\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing createGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while creating a group\");\n  }\n};\n\n// src/core/groups/listGroups.ts\nvar listGroups = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/listGroups\"\n    };\n  }\n  const params = new URLSearchParams();\n  if (options) {\n    const { offset, nameContains, limit } = options;\n    if (offset)\n      params.append(\"offset\", offset.toString());\n    if (nameContains !== void 0)\n      params.append(\"nameContains\", nameContains.toString());\n    if (limit !== void 0)\n      params.append(\"limit\", limit.toString());\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups?${params.toString()}`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing listGroups: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing groups\");\n  }\n};\n\n// src/core/groups/getGroup.ts\nvar getGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/getGroup\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups/${options.groupId}`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getGroup: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while getting info for a group\"\n    );\n  }\n};\n\n// src/core/groups/addToGroup.ts\nvar addToGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = JSON.stringify({\n    cids: options.cids\n  });\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/addToGroup\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups/${options.groupId}/cids`, {\n      method: \"PUT\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addToGroup: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while adding CIDs to group\"\n    );\n  }\n};\n\n// src/core/groups/updateGroup.ts\nvar updateGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = JSON.stringify({\n    name: options.name\n  });\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/updateGroup\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups/${options.groupId}`, {\n      method: \"PUT\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing updateGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while updating group\");\n  }\n};\n\n// src/core/groups/removeFromGroup.ts\nvar removeFromGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/removeFromGroup\"\n    };\n  }\n  const data = JSON.stringify({\n    cids: options.cids\n  });\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups/${options.groupId}/cids`, {\n      method: \"DELETE\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing removeFromGroup: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while removing CIDs from a group\"\n    );\n  }\n};\n\n// src/core/groups/deleteGroup.ts\nvar deleteGroup = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/deleteGroup\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/groups/${options.groupId}`, {\n      method: \"DELETE\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing deleteGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while deleting a group\");\n  }\n};\n\n// src/core/signatures/addSignature.ts\nvar addSignature = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = JSON.stringify({\n    signature: options.signature\n  });\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/addSignature\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(\n      `${endpoint}/v3/ipfs/signature/${options.cid}`,\n      {\n        method: \"POST\",\n        headers,\n        body: data\n      }\n    );\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 403) {\n        throw new PinataError(\n          \"Unauthorized signing, you must be the original owner of the file and it must not have a signature\",\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.data;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addSignature: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while adding signature to CID\"\n    );\n  }\n};\n\n// src/core/signatures/getSignature.ts\nvar getSignature = async (config, cid) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/getSignature\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/v3/ipfs/signature/${cid}`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    return res.data;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getSignature: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while fetching signature for CID\"\n    );\n  }\n};\n\n// src/core/signatures/removeSignature.ts\nvar removeSignature = async (config, cid) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/removeSignature\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/v3/ipfs/signature/${cid}`, {\n      method: \"DELETE\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    return \"OK\";\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addSignature: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while adding signature to CID\"\n    );\n  }\n};\n\n// src/core/gateway/analyticsTopUsage.ts\nvar analyticsTopUsage = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const params = new URLSearchParams({\n    includesCount: \"false\"\n  });\n  if (options) {\n    const {\n      cid,\n      gateway_domain,\n      start_date,\n      end_date,\n      file_name,\n      user_agent,\n      country,\n      region,\n      referer,\n      limit,\n      sort_order,\n      sort_by,\n      attribute\n    } = options;\n    if (cid)\n      params.append(\"cid\", cid);\n    if (gateway_domain)\n      params.append(\"gateway_domain\", gateway_domain);\n    if (start_date)\n      params.append(\"start_date\", start_date);\n    if (end_date)\n      params.append(\"end_date\", end_date);\n    if (file_name)\n      params.append(\"file_name\", file_name);\n    if (user_agent)\n      params.append(\"user_agent\", user_agent.toString());\n    if (country)\n      params.append(\"country\", country.toString());\n    if (region)\n      params.append(\"region\", region);\n    if (referer)\n      params.append(\"referer\", referer.toString());\n    if (limit)\n      params.append(\"limit\", limit.toString());\n    if (sort_order)\n      params.append(\"sort_order\", sort_order);\n    if (sort_by)\n      params.append(\"sort_by\", sort_by);\n    if (attribute)\n      params.append(\"by\", attribute);\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  const url = `${endpoint}/v3/ipfs/gateway_analytics_top?${params.toString()}`;\n  try {\n    let headers;\n    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n      headers = { ...config.customHeaders };\n    } else {\n      headers = {\n        Authorization: `Bearer ${config.pinataJwt}`,\n        Source: \"sdk/analyticsTopUsage\"\n      };\n    }\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    const resData = res.data;\n    return resData;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing anaytics usage: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while fetching gateway usage\"\n    );\n  }\n};\n\n// src/core/gateway/analyticsDateInterval.ts\nvar analyticsDateInterval = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const params = new URLSearchParams();\n  if (options) {\n    const {\n      cid,\n      gateway_domain,\n      start_date,\n      end_date,\n      file_name,\n      user_agent,\n      country,\n      region,\n      referer,\n      limit,\n      sort_order,\n      date_interval,\n      sort_by\n    } = options;\n    if (cid)\n      params.append(\"cid\", cid);\n    if (gateway_domain)\n      params.append(\"gateway_domain\", gateway_domain);\n    if (start_date)\n      params.append(\"start_date\", start_date);\n    if (end_date)\n      params.append(\"end_date\", end_date);\n    if (file_name)\n      params.append(\"file_name\", file_name);\n    if (user_agent)\n      params.append(\"user_agent\", user_agent.toString());\n    if (country)\n      params.append(\"country\", country.toString());\n    if (region)\n      params.append(\"region\", region);\n    if (referer)\n      params.append(\"referer\", referer.toString());\n    if (limit)\n      params.append(\"limit\", limit.toString());\n    if (sort_order)\n      params.append(\"sort_order\", sort_order);\n    if (sort_by)\n      params.append(\"sort_by\", sort_by);\n    if (date_interval)\n      params.append(\"by\", date_interval);\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  const url = `${endpoint}/v3/ipfs/gateway_analytics_time_series?${params.toString()}`;\n  try {\n    let headers;\n    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n      headers = { ...config.customHeaders };\n    } else {\n      headers = {\n        Authorization: `Bearer ${config.pinataJwt}`,\n        Source: \"sdk/analyticsDateInterval\"\n      };\n    }\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    const resData = res.data;\n    return resData;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(\n        `Error processing anaytics usage: ${error.message}`\n      );\n    }\n    throw new PinataError(\n      \"An unknown error occurred while fetching gateway usage\"\n    );\n  }\n};\n\n// src/core/gateway/swapCid.ts\nvar swapCid = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  const data = JSON.stringify({\n    swapCid: options.swapCid\n  });\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/swapCid\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/v3/ipfs/swap/${options.cid}`, {\n      method: \"PUT\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 403) {\n        throw new PinataError(\n          \"Unauthorized CID Swap\",\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 404) {\n        throw new PinataError(\n          \"CID not pinned to account\",\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    const resData = res.data;\n    return resData;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing CID Swap: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while swapping CID\");\n  }\n};\n\n// src/core/gateway/swapHistory.ts\nvar swapHistory = async (config, options) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/swapHistory\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(\n      `${endpoint}/v3/ipfs/swap/${options.cid}?domain=${options.domain}`,\n      {\n        method: \"GET\",\n        headers\n      }\n    );\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 404) {\n        throw new PinataError(\n          \"CID does not have history\",\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    const res = await request.json();\n    const resData = res.data;\n    return resData;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error fetching swap history: ${error.message}`);\n    }\n    throw new PinataError(\n      \"An unknown error occurred while fetching swap history\"\n    );\n  }\n};\n\n// src/core/gateway/deleteSwap.ts\nvar deleteSwap = async (config, cid) => {\n  if (!config) {\n    throw new ValidationError(\"Pinata configuration is missing\");\n  }\n  let headers;\n  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {\n    headers = { ...config.customHeaders };\n  } else {\n    headers = {\n      Authorization: `Bearer ${config.pinataJwt}`,\n      \"Content-Type\": \"application/json\",\n      Source: \"sdk/deleteSwap\"\n    };\n  }\n  let endpoint = \"https://api.pinata.cloud\";\n  if (config.endpointUrl) {\n    endpoint = config.endpointUrl;\n  }\n  try {\n    const request = await fetch(`${endpoint}/v3/ipfs/swap/${cid}`, {\n      method: \"DELETE\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.text();\n      if (request.status === 401 || request.status === 403) {\n        throw new AuthenticationError(\n          `Authentication failed: ${errorData}`,\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 403) {\n        throw new PinataError(\n          \"Unauthorized CID Swap Deletion\",\n          request.status,\n          errorData\n        );\n      }\n      if (request.status === 404) {\n        throw new PinataError(\n          \"CID not pinned to account\",\n          request.status,\n          errorData\n        );\n      }\n      throw new NetworkError(\n        `HTTP error: ${errorData}`,\n        request.status,\n        errorData\n      );\n    }\n    return request.statusText;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing deleteSwap: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while deleting swap\");\n  }\n};\n\n// src/core/pinataSDK.ts\nvar formatConfig = (config) => {\n  let gateway = config?.pinataGateway;\n  if (config && gateway) {\n    if (gateway && !gateway.startsWith(\"https://\")) {\n      gateway = `https://${gateway}`;\n    }\n    config.pinataGateway = gateway;\n  }\n  return config;\n};\nvar PinataSDK = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n    this.upload = new Upload(this.config);\n    this.gateways = new Gateways(this.config);\n    this.usage = new Usage(this.config);\n    this.keys = new Keys(this.config);\n    this.groups = new Groups(this.config);\n    this.signatures = new Signatures(this.config);\n  }\n  setNewHeaders(headers) {\n    if (!this.config) {\n      this.config = { pinataJwt: \"\", customHeaders: {} };\n    }\n    this.config.customHeaders = { ...this.config.customHeaders, ...headers };\n    this.upload.updateConfig(this.config);\n    this.gateways.updateConfig(this.config);\n    this.usage.updateConfig(this.config);\n    this.keys.updateConfig(this.config);\n    this.groups.updateConfig(this.config);\n    this.signatures.updateConfig(this.config);\n  }\n  testAuthentication() {\n    return testAuthentication(this.config);\n  }\n  unpin(files) {\n    return unpinFile(this.config, files);\n  }\n  listFiles() {\n    return new FilterFiles(this.config);\n  }\n  updateMetadata(options) {\n    return updateMetadata(this.config, options);\n  }\n  pinJobs() {\n    return new FilterPinJobs(this.config);\n  }\n};\nvar UploadBuilder = class {\n  constructor(config, uploadFunction, ...args) {\n    this.config = config;\n    this.uploadFunction = uploadFunction;\n    this.args = args;\n    this.version = 1;\n  }\n  addMetadata(metadata) {\n    this.metadata = metadata;\n    return this;\n  }\n  key(jwt) {\n    this.keys = jwt;\n    return this;\n  }\n  cidVersion(v) {\n    this.version = v;\n    return this;\n  }\n  group(groupId) {\n    this.groupId = groupId;\n    return this;\n  }\n  peerAddress(peerAddresses) {\n    this.peerAddresses = peerAddresses;\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    const options = this.args[this.args.length - 1] || {};\n    if (this.metadata) {\n      options.metadata = this.metadata;\n    }\n    if (this.keys) {\n      options.keys = this.keys;\n    }\n    if (this.groupId) {\n      options.groupId = this.groupId;\n    }\n    if (this.version) {\n      options.cidVersion = this.version;\n    }\n    if (this.peerAddresses && \"peerAddresses\" in options) {\n      options.peerAddresses = this.peerAddresses;\n    }\n    this.args[this.args.length - 1] = options;\n    return this.uploadFunction(this.config, ...this.args).then(\n      onfulfilled,\n      onrejected\n    );\n  }\n};\nvar Upload = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  file(file, options) {\n    return new UploadBuilder(this.config, uploadFile, file, options);\n  }\n  fileArray(files, options) {\n    return new UploadBuilder(this.config, uploadFileArray, files, options);\n  }\n  base64(base64String, options) {\n    return new UploadBuilder(this.config, uploadBase64, base64String, options);\n  }\n  url(url, options) {\n    return new UploadBuilder(this.config, uploadUrl, url, options);\n  }\n  json(data, options) {\n    return new UploadBuilder(this.config, uploadJson, data, options);\n  }\n  cid(cid, options) {\n    return new UploadBuilder(this.config, uploadCid, cid, options);\n  }\n};\nvar FilterFiles = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  cid(cid) {\n    this.query.cid = cid;\n    return this;\n  }\n  pinStart(date) {\n    this.query.pinStart = date;\n    return this;\n  }\n  pinEnd(date) {\n    this.query.pinEnd = date;\n    return this;\n  }\n  pinSizeMin(size) {\n    this.query.pinSizeMin = size;\n    return this;\n  }\n  pinSizeMax(size) {\n    this.query.pinSizeMax = size;\n    return this;\n  }\n  pageLimit(limit) {\n    this.query.pageLimit = limit;\n    return this;\n  }\n  pageOffset(offset) {\n    this.query.pageOffset = offset;\n    return this;\n  }\n  name(name) {\n    this.query.name = name;\n    return this;\n  }\n  group(groupId) {\n    this.query.groupId = groupId;\n    return this;\n  }\n  keyValue(key, value, operator) {\n    this.query.key = key;\n    this.query.value = value;\n    if (operator) {\n      this.query.operator = operator;\n    }\n    return this;\n  }\n  then(onfulfilled) {\n    return listFiles(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise((resolve) => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    const limit = this.query.pageLimit || 10;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.pageOffset = offset;\n      this.query.pageLimit = limit;\n      const items = await listFiles(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Gateways = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  get(cid) {\n    return getCid(this.config, cid);\n  }\n  convert(url) {\n    return convertIPFSUrl(this.config, url);\n  }\n  topUsageAnalytics(options) {\n    return new TopGatewayAnalyticsBuilder(\n      this.config,\n      options.domain,\n      options.start,\n      options.end,\n      options.sortBy,\n      options.attribute\n    );\n  }\n  dateIntervalAnalytics(options) {\n    return new TimeIntervalGatewayAnalyticsBuilder(\n      this.config,\n      options.domain,\n      options.start,\n      options.end,\n      options.interval\n    );\n  }\n  swapCid(options) {\n    return swapCid(this.config, options);\n  }\n  swapHistory(options) {\n    return swapHistory(this.config, options);\n  }\n  deleteSwap(cid) {\n    return deleteSwap(this.config, cid);\n  }\n};\nvar FilterPinJobs = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  cid(cid) {\n    this.query.ipfs_pin_hash = cid;\n    return this;\n  }\n  status(status) {\n    this.query.status = status;\n    return this;\n  }\n  pageLimit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  pageOffset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  sort(sort) {\n    this.query.sort = sort;\n    return this;\n  }\n  then(onfulfilled) {\n    return pinJobs(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise((resolve) => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    const limit = this.query.limit || 10;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      this.query.limit = limit;\n      const items = await pinJobs(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Usage = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  pinnedFileCount() {\n    return pinnedFileCount(this.config);\n  }\n  totalStorageSize() {\n    return totalStorageUsage(this.config);\n  }\n};\nvar Keys = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  create(options) {\n    return createKey(this.config, options);\n  }\n  list() {\n    return new FilterKeys(this.config);\n  }\n  revoke(keys) {\n    return revokeKeys(this.config, keys);\n  }\n};\nvar FilterKeys = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  revoked(revoked) {\n    this.query.revoked = revoked;\n    return this;\n  }\n  limitedUse(limitedUse) {\n    this.query.limitedUse = limitedUse;\n    return this;\n  }\n  exhausted(exhausted) {\n    this.query.exhausted = exhausted;\n    return this;\n  }\n  name(name) {\n    this.query.name = name;\n    return this;\n  }\n  then(onfulfilled) {\n    return listKeys(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise((resolve) => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      const items = await listKeys(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Groups = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  create(options) {\n    return createGroup(this.config, options);\n  }\n  list() {\n    return new FilterGroups(this.config);\n  }\n  get(options) {\n    return getGroup(this.config, options);\n  }\n  addCids(options) {\n    return addToGroup(this.config, options);\n  }\n  removeCids(options) {\n    return removeFromGroup(this.config, options);\n  }\n  update(options) {\n    return updateGroup(this.config, options);\n  }\n  delete(options) {\n    return deleteGroup(this.config, options);\n  }\n};\nvar FilterGroups = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  name(nameContains) {\n    this.query.nameContains = nameContains;\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  then(onfulfilled) {\n    return listGroups(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise((resolve) => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      const items = await listGroups(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Signatures = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n  }\n  add(options) {\n    return addSignature(this.config, options);\n  }\n  get(cid) {\n    return getSignature(this.config, cid);\n  }\n  delete(cid) {\n    return removeSignature(this.config, cid);\n  }\n};\nvar GatewayAnalyticsBuilder = class {\n  constructor(config, query) {\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n    this.query = query;\n  }\n  cid(cid) {\n    this.query.cid = cid;\n    return this;\n  }\n  fileName(fileName) {\n    this.query.file_name = fileName;\n    return this;\n  }\n  userAgent(userAgent) {\n    this.query.user_agent = userAgent;\n    return this;\n  }\n  country(country) {\n    this.query.country = country;\n    return this;\n  }\n  region(region) {\n    this.query.region = region;\n    return this;\n  }\n  referer(referer) {\n    this.query.referer = referer;\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  sort(order) {\n    this.query.sort_order = order;\n    return this;\n  }\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise((resolve) => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async getAnalytics() {\n    await this.rateLimit();\n    throw new Error(\"getAnalytics method must be implemented in derived class\");\n  }\n  then(onfulfilled) {\n    return this.getAnalytics().then(onfulfilled);\n  }\n};\nvar TopGatewayAnalyticsBuilder = class extends GatewayAnalyticsBuilder {\n  constructor(config, domain, start, end, sortBy, attribute) {\n    super(config, {\n      gateway_domain: domain,\n      start_date: start,\n      end_date: end,\n      sort_by: sortBy,\n      attribute\n    });\n  }\n  async getAnalytics() {\n    return analyticsTopUsage(this.config, this.query);\n  }\n  async all() {\n    return this.getAnalytics();\n  }\n};\nvar TimeIntervalGatewayAnalyticsBuilder = class extends GatewayAnalyticsBuilder {\n  constructor(config, domain, start, end, dateInterval) {\n    super(config, {\n      gateway_domain: domain,\n      start_date: start,\n      end_date: end,\n      date_interval: dateInterval\n    });\n  }\n  sortBy(sortBy) {\n    this.query.sort_by = sortBy;\n    return this;\n  }\n  async getAnalytics() {\n    return analyticsDateInterval(this.config, this.query);\n  }\n  async all() {\n    return this.getAnalytics();\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluYXRhL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixJQUFJO0FBQ0o7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsSUFBSTtBQUNKO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcGluYXRhL2Rpc3QvaW5kZXgubWpzP2Q3ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL2N1c3RvbS1lcnJvcnMudHNcbnZhciBQaW5hdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHRoaXMubmFtZSA9IFwiUGluYXRhRXJyb3JcIjtcbiAgfVxufTtcbnZhciBOZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIFBpbmF0YUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCI7XG4gIH1cbn07XG52YXIgQXV0aGVudGljYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgUGluYXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzQ29kZSwgZGV0YWlscyk7XG4gICAgdGhpcy5uYW1lID0gXCJBdXRoZW50aWNhdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBQaW5hdGFFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCB2b2lkIDAsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiVmFsaWRhdGlvbkVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2F1dGhlbnRpY2F0aW9uL3Rlc3RBdXRoZW50aWNhdGlvbi50c1xudmFyIHRlc3RBdXRoZW50aWNhdGlvbiA9IGFzeW5jIChjb25maWcpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBTb3VyY2U6IFwic2RrL3Rlc3RBdXRoZW50aWNhdGlvblwiXG4gICAgfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vZGF0YS90ZXN0QXV0aGVudGljYXRpb25gLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgYXV0aGVudGljYXRpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgdGVzdGluZyBhdXRoZW50aWNhdGlvblwiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy9maWxlLnRzXG52YXIgdXBsb2FkRmlsZSA9IGFzeW5jIChjb25maWcsIGZpbGUsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBqd3QgPSBvcHRpb25zPy5rZXlzIHx8IGNvbmZpZy5waW5hdGFKd3Q7XG4gIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUsIGZpbGUubmFtZSk7XG4gIGRhdGEuYXBwZW5kKFxuICAgIFwicGluYXRhT3B0aW9uc1wiLFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGNpZFZlcnNpb246IG9wdGlvbnM/LmNpZFZlcnNpb24sXG4gICAgICBncm91cElkOiBvcHRpb25zPy5ncm91cElkXG4gICAgfSlcbiAgKTtcbiAgZGF0YS5hcHBlbmQoXG4gICAgXCJwaW5hdGFNZXRhZGF0YVwiLFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG5hbWU6IG9wdGlvbnM/Lm1ldGFkYXRhPy5uYW1lIHx8IGZpbGUubmFtZSB8fCBcIkZpbGUgZnJvbSBTREtcIixcbiAgICAgIGtleXZhbHVlczogb3B0aW9ucz8ubWV0YWRhdGE/LmtleVZhbHVlc1xuICAgIH0pXG4gICk7XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0fWAsXG4gICAgICBTb3VyY2U6IFwic2RrL2ZpbGVcIlxuICAgIH07XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKGAke2VuZHBvaW50fS9waW5uaW5nL3BpbkZpbGVUb0lQRlNgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGRhdGFcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKGBFcnJvciB1cGxvYWRpbmcgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHVwbG9hZGluZyB0aGUgZmlsZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy9maWxlQXJyYXkudHNcbnZhciB1cGxvYWRGaWxlQXJyYXkgPSBhc3luYyAoY29uZmlnLCBmaWxlcywgb3B0aW9ucykgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGNvbnN0IGp3dCA9IG9wdGlvbnM/LmtleXMgfHwgY29uZmlnPy5waW5hdGFKd3Q7XG4gIGNvbnN0IGZvbGRlciA9IG9wdGlvbnM/Lm1ldGFkYXRhPy5uYW1lIHx8IFwiZm9sZGVyX2Zyb21fc2RrXCI7XG4gIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIEFycmF5LmZyb20oZmlsZXMpKSB7XG4gICAgZGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUsIGAke2ZvbGRlcn0vJHtmaWxlLm5hbWV9YCk7XG4gIH1cbiAgZGF0YS5hcHBlbmQoXG4gICAgXCJwaW5hdGFNZXRhZGF0YVwiLFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG5hbWU6IGZvbGRlcixcbiAgICAgIGtleXZhbHVlczogb3B0aW9ucz8ubWV0YWRhdGE/LmtleVZhbHVlc1xuICAgIH0pXG4gICk7XG4gIGRhdGEuYXBwZW5kKFxuICAgIFwicGluYXRhT3B0aW9uc1wiLFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGNpZFZlcnNpb246IG9wdGlvbnM/LmNpZFZlcnNpb24sXG4gICAgICBncm91cElkOiBvcHRpb25zPy5ncm91cElkXG4gICAgfSlcbiAgKTtcbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCxcbiAgICAgIFNvdXJjZTogXCJzZGsvZmlsZUFycmF5XCJcbiAgICB9O1xuICB9XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vcGlubmluZy9waW5GaWxlVG9JUEZTYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBmaWxlQXJyYXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHVwbG9hZGluZyBhbiBhcnJheSBvZiBmaWxlc1wiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy9iYXNlNjQudHNcbnZhciB1cGxvYWRCYXNlNjQgPSBhc3luYyAoY29uZmlnLCBiYXNlNjRTdHJpbmcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBqd3QgPSBvcHRpb25zPy5rZXlzIHx8IGNvbmZpZz8ucGluYXRhSnd0O1xuICBjb25zdCBuYW1lID0gb3B0aW9ucz8ubWV0YWRhdGE/Lm5hbWUgPyBvcHRpb25zPy5tZXRhZGF0YT8ubmFtZSA6IFwiYmFzZTY0IHN0cmluZ1wiO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjRTdHJpbmcsIFwiYmFzZTY0XCIpO1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGRhdGEuYXBwZW5kKFwiZmlsZVwiLCBibG9iLCBuYW1lKTtcbiAgZGF0YS5hcHBlbmQoXG4gICAgXCJwaW5hdGFPcHRpb25zXCIsXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY2lkVmVyc2lvbjogb3B0aW9ucz8uY2lkVmVyc2lvbixcbiAgICAgIGdyb3VwSWQ6IG9wdGlvbnM/Lmdyb3VwSWRcbiAgICB9KVxuICApO1xuICBkYXRhLmFwcGVuZChcbiAgICBcInBpbmF0YU1ldGFkYXRhXCIsXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbmFtZSxcbiAgICAgIGtleXZhbHVlczogb3B0aW9ucz8ubWV0YWRhdGE/LmtleVZhbHVlc1xuICAgIH0pXG4gICk7XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0fWAsXG4gICAgICBTb3VyY2U6IFwic2RrL2Jhc2U2NFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvcGluRmlsZVRvSVBGU2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgYmFzZTY0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gdXBsb2FkIGJhc2U2NFwiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy91cmwudHNcbnZhciB1cGxvYWRVcmwgPSBhc3luYyAoY29uZmlnLCB1cmwsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBqd3QgPSBvcHRpb25zPy5rZXlzIHx8IGNvbmZpZz8ucGluYXRhSnd0O1xuICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIGlmICghc3RyZWFtLm9rKSB7XG4gICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgc3RyZWFtLnRleHQoKTtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICBzdHJlYW0uc3RhdHVzLFxuICAgICAgZXJyb3JEYXRhXG4gICAgKTtcbiAgfVxuICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHN0cmVhbS5hcnJheUJ1ZmZlcigpO1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSk7XG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zPy5tZXRhZGF0YT8ubmFtZSA/PyBcInVybF91cGxvYWRcIjtcbiAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgbmFtZSk7XG4gIGRhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlLCBuYW1lKTtcbiAgZGF0YS5hcHBlbmQoXG4gICAgXCJwaW5hdGFPcHRpb25zXCIsXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY2lkVmVyc2lvbjogb3B0aW9ucz8uY2lkVmVyc2lvbixcbiAgICAgIGdyb3VwSWQ6IG9wdGlvbnM/Lmdyb3VwSWRcbiAgICB9KVxuICApO1xuICBkYXRhLmFwcGVuZChcbiAgICBcInBpbmF0YU1ldGFkYXRhXCIsXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbmFtZSxcbiAgICAgIGtleXZhbHVlczogb3B0aW9ucz8ubWV0YWRhdGE/LmtleVZhbHVlc1xuICAgIH0pXG4gICk7XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0fWAsXG4gICAgICBTb3VyY2U6IFwic2RrL3VybFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvcGluRmlsZVRvSVBGU2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgdXJsOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgdXBsb2FkaW5nIGJ5IHVybFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy9qc29uLnRzXG52YXIgdXBsb2FkSnNvbiA9IGFzeW5jIChjb25maWcsIGpzb25EYXRhLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3Qgand0ID0gb3B0aW9ucz8ua2V5cyB8fCBjb25maWc/LnBpbmF0YUp3dDtcbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBwaW5hdGFDb250ZW50OiBqc29uRGF0YSxcbiAgICBwaW5hdGFPcHRpb25zOiB7XG4gICAgICBjaWRWZXJzaW9uOiBvcHRpb25zPy5jaWRWZXJzaW9uLFxuICAgICAgZ3JvdXBJZDogb3B0aW9ucz8uZ3JvdXBJZFxuICAgIH0sXG4gICAgcGluYXRhTWV0YWRhdGE6IHtcbiAgICAgIG5hbWU6IG9wdGlvbnM/Lm1ldGFkYXRhPy5uYW1lIHx8IFwianNvblwiLFxuICAgICAga2V5dmFsdWVzOiBvcHRpb25zPy5tZXRhZGF0YT8ua2V5VmFsdWVzXG4gICAgfVxuICB9KTtcbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9qc29uXCJcbiAgICB9O1xuICB9XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vcGlubmluZy9waW5KU09OVG9JUEZTYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBqc29uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgdXBsb2FkaW5nIGpzb25cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL3Bpbm5pbmcvY2lkLnRzXG52YXIgdXBsb2FkQ2lkID0gYXN5bmMgKGNvbmZpZywgY2lkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3Qgand0ID0gb3B0aW9ucz8ua2V5cyB8fCBjb25maWc/LnBpbmF0YUp3dDtcbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9jaWRcIlxuICAgIH07XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBoYXNoVG9QaW46IGNpZCxcbiAgICBwaW5hdGFNZXRhZGF0YToge1xuICAgICAgbmFtZTogb3B0aW9ucz8ubWV0YWRhdGEgPyBvcHRpb25zPy5tZXRhZGF0YT8ubmFtZSA6IGNpZCxcbiAgICAgIGtleXZhbHVlczogb3B0aW9ucz8ubWV0YWRhdGE/LmtleVZhbHVlc1xuICAgIH0sXG4gICAgcGluYXRhT3B0aW9uczoge1xuICAgICAgaG9zdE5vZGVzOiBvcHRpb25zPy5wZWVyQWRkcmVzc2VzID8gb3B0aW9ucy5wZWVyQWRkcmVzc2VzIDogXCJcIixcbiAgICAgIGdyb3VwSWQ6IG9wdGlvbnM/Lmdyb3VwSWRcbiAgICB9XG4gIH0pO1xuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvcGluQnlIYXNoYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjaWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBwaW5uaW5nIGJ5IENJRFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGlubmluZy91bnBpbi50c1xudmFyIHdhaXQgPSAobWlsbGlzZWNvbmRzKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbWlsbGlzZWNvbmRzKTtcbiAgfSk7XG59O1xudmFyIHVucGluRmlsZSA9IGFzeW5jIChjb25maWcsIGZpbGVzKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgU291cmNlOiBcInNkay91bnBpblwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgZm9yIChjb25zdCBoYXNoIG9mIGZpbGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvdW5waW4vJHtoYXNofWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHdhaXQoMzAwKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0dXM6IHJlc3VsdFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGBFcnJvciB1bnBpbm5pbmcgZmlsZSAke2hhc2h9OiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHVucGlubmluZyBmaWxlICR7aGFzaH1gO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0dXM6IGVycm9yTWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zZXM7XG59O1xuXG4vLyBzcmMvY29yZS9kYXRhL2xpc3RGaWxlcy50c1xudmFyIGxpc3RGaWxlcyA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBpbmNsdWRlc0NvdW50OiBcImZhbHNlXCJcbiAgfSk7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2lkLFxuICAgICAgcGluU3RhcnQsXG4gICAgICBwaW5FbmQsXG4gICAgICBwaW5TaXplTWluLFxuICAgICAgcGluU2l6ZU1heCxcbiAgICAgIHBhZ2VMaW1pdCxcbiAgICAgIHBhZ2VPZmZzZXQsXG4gICAgICBuYW1lLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBvcGVyYXRvcixcbiAgICAgIGdyb3VwSWRcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoY2lkKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImNpZFwiLCBjaWQpO1xuICAgIGlmIChwaW5TdGFydClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJwaW5TdGFydFwiLCBwaW5TdGFydCk7XG4gICAgaWYgKHBpbkVuZClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJwaW5FbmRcIiwgcGluRW5kKTtcbiAgICBpZiAocGluU2l6ZU1pbilcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJwaW5TaXplTWluXCIsIHBpblNpemVNaW4udG9TdHJpbmcoKSk7XG4gICAgaWYgKHBpblNpemVNYXgpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwicGluU2l6ZU1heFwiLCBwaW5TaXplTWF4LnRvU3RyaW5nKCkpO1xuICAgIGlmIChwYWdlTGltaXQpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwicGFnZUxpbWl0XCIsIHBhZ2VMaW1pdC50b1N0cmluZygpKTtcbiAgICBpZiAocGFnZU9mZnNldClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJwYWdlT2Zmc2V0XCIsIHBhZ2VPZmZzZXQudG9TdHJpbmcoKSk7XG4gICAgaWYgKGdyb3VwSWQpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwiZ3JvdXBJZFwiLCBncm91cElkKTtcbiAgICBpZiAobmFtZSlcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVtuYW1lXVwiLCBuYW1lKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBjb25zdCBrZXlWYWx1ZVBhcmFtID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBba2V5XTogeyB2YWx1ZSwgb3A6IG9wZXJhdG9yIHx8IFwiZXFcIiB9XG4gICAgICB9KTtcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVtrZXl2YWx1ZXNdXCIsIGtleVZhbHVlUGFyYW0pO1xuICAgIH1cbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnR9L2RhdGEvcGluTGlzdD9zdGF0dXM9cGlubmVkJiR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgdHJ5IHtcbiAgICBsZXQgaGVhZGVycztcbiAgICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICAgIFNvdXJjZTogXCJzZGsvbGlzdEZpbGVzXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIHJldHVybiByZXMucm93cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgbGlzdCBmaWxlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGxpc3RpbmcgZmlsZXNcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2RhdGEvdXBkYXRlTWV0YWRhdGEudHNcbnZhciB1cGRhdGVNZXRhZGF0YSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBkYXRhID0ge1xuICAgIGlwZnNQaW5IYXNoOiBvcHRpb25zLmNpZCxcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAga2V5dmFsdWVzOiBvcHRpb25zLmtleVZhbHVlc1xuICB9O1xuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay91cGRhdGVNZXRhZGF0YVwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvaGFzaE1ldGFkYXRhYCwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgdXBkYXRlTWV0YWRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHVwZGF0aW5nIG1ldGFkYXRhXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZ2F0ZXdheS10b29scy50c1xudmFyIGlzSVBGU01vZHVsZTtcbmFzeW5jIGZ1bmN0aW9uIGdldElzSVBGUygpIHtcbiAgaWYgKCFpc0lQRlNNb2R1bGUpIHtcbiAgICBpc0lQRlNNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXCJpcy1pcGZzXCIpO1xuICB9XG4gIHJldHVybiBpc0lQRlNNb2R1bGU7XG59XG5hc3luYyBmdW5jdGlvbiBjb250YWluc0NJRChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGlzSVBGUyA9IGF3YWl0IGdldElzSVBGUygpO1xuICBjb25zdCBzdGFydHNXaXRoQ0lEID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KFwiL1wiKTtcbiAgICByZXR1cm4gaXNJUEZTLmNpZChwYXJ0c1swXSkgPyBwYXJ0c1swXSA6IG51bGw7XG4gIH07XG4gIGNvbnN0IGRpcmVjdENJRCA9IHN0YXJ0c1dpdGhDSUQoaW5wdXQpO1xuICBpZiAoZGlyZWN0Q0lEKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5zQ2lkOiB0cnVlLFxuICAgICAgY2lkOiBkaXJlY3RDSURcbiAgICB9O1xuICB9XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChpbnB1dCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcGFydHMgPSBpbnB1dC5zcGxpdCgvXFwvfFxcPy8pO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgY29uc3QgY2lkID0gc3RhcnRzV2l0aENJRChwYXJ0KTtcbiAgICAgIGlmIChjaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250YWluc0NpZDogdHJ1ZSxcbiAgICAgICAgICBjaWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5zQ2lkOiBmYWxzZSxcbiAgICAgIGNpZDogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3Qgc3ViZG9tYWlucyA9IHVybC5ob3N0bmFtZS5zcGxpdChcIi5cIik7XG4gIGZvciAoY29uc3Qgc3ViZG9tYWluIG9mIHN1YmRvbWFpbnMpIHtcbiAgICBpZiAoaXNJUEZTLmNpZChzdWJkb21haW4pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluc0NpZDogdHJ1ZSxcbiAgICAgICAgY2lkOiBzdWJkb21haW5cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhdGhQYXJ0cyA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIik7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXRoUGFydHMpIHtcbiAgICBjb25zdCBjaWQgPSBzdGFydHNXaXRoQ0lEKHBhcnQpO1xuICAgIGlmIChjaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5zQ2lkOiB0cnVlLFxuICAgICAgICBjaWRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29udGFpbnNDaWQ6IGZhbHNlLFxuICAgIGNpZDogbnVsbFxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvRGVzaXJlZEdhdGV3YXkoc291cmNlVXJsLCBkZXNpcmVkR2F0ZXdheVByZWZpeCkge1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29udGFpbnNDSUQoc291cmNlVXJsKTtcbiAgaWYgKHJlc3VsdHMuY29udGFpbnNDaWQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmwgZG9lcyBub3QgY29udGFpbiBDSURcIik7XG4gIH1cbiAgaWYgKCFzb3VyY2VVcmwuc3RhcnRzV2l0aChcImh0dHBzXCIpICYmICFzb3VyY2VVcmwuc3RhcnRzV2l0aChcImlwZnM6Ly9cIikpIHtcbiAgICByZXR1cm4gYCR7ZGVzaXJlZEdhdGV3YXlQcmVmaXh9L2lwZnMvJHtzb3VyY2VVcmx9YDtcbiAgfVxuICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHNvdXJjZVVybCk7XG4gIGNvbnN0IHBhdGggPSB1cmxPYmoucGF0aG5hbWUgKyB1cmxPYmouc2VhcmNoICsgdXJsT2JqLmhhc2g7XG4gIGlmIChzb3VyY2VVcmwuc3RhcnRzV2l0aChgaXBmczovLyR7cmVzdWx0cy5jaWR9YCkpIHtcbiAgICByZXR1cm4gYCR7ZGVzaXJlZEdhdGV3YXlQcmVmaXh9L2lwZnMvJHtyZXN1bHRzLmNpZH0ke3BhdGh9YDtcbiAgfVxuICBpZiAoc291cmNlVXJsLmluY2x1ZGVzKGAvaXBmcy8ke3Jlc3VsdHMuY2lkfWApKSB7XG4gICAgcmV0dXJuIGAke2Rlc2lyZWRHYXRld2F5UHJlZml4fSR7cGF0aH1gO1xuICB9XG4gIGlmIChzb3VyY2VVcmwuaW5jbHVkZXMoYC9pcG5zLyR7cmVzdWx0cy5jaWR9YCkpIHtcbiAgICByZXR1cm4gYCR7ZGVzaXJlZEdhdGV3YXlQcmVmaXh9JHtwYXRofWA7XG4gIH1cbiAgaWYgKHVybE9iai5ob3N0bmFtZS5pbmNsdWRlcyhyZXN1bHRzLmNpZCkpIHtcbiAgICByZXR1cm4gYCR7ZGVzaXJlZEdhdGV3YXlQcmVmaXh9L2lwZnMvJHtyZXN1bHRzLmNpZH0ke3BhdGh9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJ1bnN1cHBvcnRlZCBVUkwgcGF0dGVybiwgcGxlYXNlIHN1Ym1pdCBhIGdpdGh1YiBpc3N1ZSB3aXRoIHRoZSBVUkwgdXRpbGl6ZWRcIlxuICApO1xufVxuXG4vLyBzcmMvY29yZS9nYXRld2F5L2dldENpZC50c1xudmFyIGdldENpZCA9IGFzeW5jIChjb25maWcsIGNpZCkgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGxldCBkYXRhO1xuICBsZXQgbmV3VXJsO1xuICBuZXdVcmwgPSBhd2FpdCBjb252ZXJ0VG9EZXNpcmVkR2F0ZXdheShjaWQsIGNvbmZpZz8ucGluYXRhR2F0ZXdheSk7XG4gIGlmIChjb25maWc/LnBpbmF0YUdhdGV3YXlLZXkpIHtcbiAgICBuZXdVcmwgPSBgJHtuZXdVcmx9P3BpbmF0YUdhdGV3YXlUb2tlbj0ke2NvbmZpZz8ucGluYXRhR2F0ZXdheUtleX1gO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKG5ld1VybCk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIEZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcyhcInRleHQvXCIpKSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXF1ZXN0LmJsb2IoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgZGF0YSxcbiAgICAgIGNvbnRlbnRUeXBlXG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBnZXRDaWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGdldHRpbmcgQ0lEIGNvbnRlbnRzXCJcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9nYXRld2F5L2NvbnZlcnRJUEZTVXJsLnRzXG52YXIgY29udmVydElQRlNVcmwgPSBhc3luYyAoY29uZmlnLCB1cmwpID0+IHtcbiAgbGV0IG5ld1VybDtcbiAgbmV3VXJsID0gYXdhaXQgY29udmVydFRvRGVzaXJlZEdhdGV3YXkodXJsLCBjb25maWc/LnBpbmF0YUdhdGV3YXkpO1xuICBpZiAoY29uZmlnPy5waW5hdGFHYXRld2F5S2V5KSB7XG4gICAgYCR7bmV3VXJsfT9waW5hdGFHYXRld2F5VG9rZW49JHtjb25maWc/LnBpbmF0YUdhdGV3YXlLZXl9YDtcbiAgfVxuICByZXR1cm4gbmV3VXJsO1xufTtcblxuLy8gc3JjL2NvcmUvZGF0YS9waW5Kb2JzLnRzXG52YXIgcGluSm9icyA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBpbmNsdWRlc0NvdW50OiBcImZhbHNlXCJcbiAgfSk7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpcGZzX3Bpbl9oYXNoOiBjaWQsIHN0YXR1cywgc29ydCwgbGltaXQsIG9mZnNldCB9ID0gb3B0aW9ucztcbiAgICBpZiAoY2lkKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImlwZnNfcGluX2hhc2hcIiwgY2lkLnRvU3RyaW5nKCkpO1xuICAgIGlmIChzdGF0dXMpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwic3RhdHVzXCIsIHN0YXR1cy50b1N0cmluZygpKTtcbiAgICBpZiAoc29ydClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0XCIsIHNvcnQudG9TdHJpbmcoKSk7XG4gICAgaWYgKGxpbWl0KVxuICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgIGlmIChvZmZzZXQpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwib2Zmc2V0XCIsIG9mZnNldC50b1N0cmluZygpKTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnR9L3Bpbm5pbmcvcGluSm9icz8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgU291cmNlOiBcInNkay9waW5Kb2JzXCJcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcy5yb3dzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwaW5Kb2JzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbGlzdGluZyBwaW4gam9ic1wiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvZGF0YS9waW5uZWRGaWxlVXNhZ2UudHNcbnZhciBwaW5uZWRGaWxlQ291bnQgPSBhc3luYyAoY29uZmlnKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgU291cmNlOiBcInNkay9waW5uZWRGaWxlVXNhZ2VcIlxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L2RhdGEvdXNlclBpbm5lZERhdGFUb3RhbGAsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIHJldHVybiByZXMucGluX2NvdW50O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgcGlubmVkRmlsZVVzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGdldHRpbmcgcGlubmVkIGZpbGUgdXNhZ2VcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2RhdGEvdG90YWxTdG9yYWdlVXNhZ2UudHNcbnZhciB0b3RhbFN0b3JhZ2VVc2FnZSA9IGFzeW5jIChjb25maWcpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBTb3VyY2U6IFwic2RrL3RvdGFsU3RvcmFnZVVzYWdlXCJcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKGAke2VuZHBvaW50fS9kYXRhL3VzZXJQaW5uZWREYXRhVG90YWxgLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzLnBpbl9zaXplX3RvdGFsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgdG90YWxTdG9yYWdlVXNhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZ2V0dGluZyB0b3RhbCBzdG9yYWdlIHVzYWdlXCJcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9rZXlzL2NyZWF0ZUtleS50c1xudmFyIGNyZWF0ZUtleSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9jcmVhdGVLZXlcIlxuICAgIH07XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3YzL3BpbmF0YS9rZXlzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjcmVhdGVLZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyBBUEkga2V5XCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9rZXlzL2xpc3RLZXlzLnRzXG52YXIgbGlzdEtleXMgPSBhc3luYyAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFNvdXJjZTogXCJzZGsvbGlzdEtleXNcIlxuICAgIH07XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBpZiAob3B0aW9ucykge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBuYW1lLCByZXZva2VkLCBsaW1pdGVkVXNlLCBleGhhdXN0ZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG9mZnNldClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgb2Zmc2V0LnRvU3RyaW5nKCkpO1xuICAgIGlmIChyZXZva2VkICE9PSB2b2lkIDApXG4gICAgICBwYXJhbXMuYXBwZW5kKFwicmV2b2tlZFwiLCByZXZva2VkLnRvU3RyaW5nKCkpO1xuICAgIGlmIChsaW1pdGVkVXNlICE9PSB2b2lkIDApXG4gICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRlZFVzZVwiLCBsaW1pdGVkVXNlLnRvU3RyaW5nKCkpO1xuICAgIGlmIChleGhhdXN0ZWQgIT09IHZvaWQgMClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJleGhhdXN0ZWRcIiwgZXhoYXVzdGVkLnRvU3RyaW5nKCkpO1xuICAgIGlmIChuYW1lKVxuICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7ZW5kcG9pbnR9L3YzL3BpbmF0YS9rZXlzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIHJldHVybiByZXMua2V5cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgbGlzdEtleXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsaXN0aW5nIEFQSSBrZXlzXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9rZXlzL3Jldm9rZUtleXMudHNcbnZhciB3YWl0MiA9IChtaWxsaXNlY29uZHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXNlY29uZHMpO1xuICB9KTtcbn07XG52YXIgcmV2b2tlS2V5cyA9IGFzeW5jIChjb25maWcsIGtleXMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9yZXZva2VLZXlzXCJcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3YzL3BpbmF0YS9rZXlzLyR7a2V5fWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHdhaXQyKDMwMCk7XG4gICAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgICAgcmVzcG9uc2VzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHN0YXR1czogcmVzdWx0XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gYEVycm9yIHJldm9raW5nIGtleSAke2tleX06ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gYEFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV2b2tpbmcga2V5ICR7a2V5fWA7XG4gICAgICB9XG4gICAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgc3RhdHVzOiBlcnJvck1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzcG9uc2VzO1xufTtcblxuLy8gc3JjL2NvcmUvZ3JvdXBzL2NyZWF0ZUdyb3VwLnRzXG52YXIgY3JlYXRlR3JvdXAgPSBhc3luYyAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9jcmVhdGVHcm91cFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L2dyb3Vwc2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY3JlYXRlR3JvdXA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyBhIGdyb3VwXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9ncm91cHMvbGlzdEdyb3Vwcy50c1xudmFyIGxpc3RHcm91cHMgPSBhc3luYyAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFNvdXJjZTogXCJzZGsvbGlzdEdyb3Vwc1wiXG4gICAgfTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIG5hbWVDb250YWlucywgbGltaXQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG9mZnNldClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgb2Zmc2V0LnRvU3RyaW5nKCkpO1xuICAgIGlmIChuYW1lQ29udGFpbnMgIT09IHZvaWQgMClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lQ29udGFpbnNcIiwgbmFtZUNvbnRhaW5zLnRvU3RyaW5nKCkpO1xuICAgIGlmIChsaW1pdCAhPT0gdm9pZCAwKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICB9XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vZ3JvdXBzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgbGlzdEdyb3VwczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGxpc3RpbmcgZ3JvdXBzXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9ncm91cHMvZ2V0R3JvdXAudHNcbnZhciBnZXRHcm91cCA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9nZXRHcm91cFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L2dyb3Vwcy8ke29wdGlvbnMuZ3JvdXBJZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBnZXRHcm91cDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZ2V0dGluZyBpbmZvIGZvciBhIGdyb3VwXCJcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9ncm91cHMvYWRkVG9Hcm91cC50c1xudmFyIGFkZFRvR3JvdXAgPSBhc3luYyAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBjaWRzOiBvcHRpb25zLmNpZHNcbiAgfSk7XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBTb3VyY2U6IFwic2RrL2FkZFRvR3JvdXBcIlxuICAgIH07XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKGAke2VuZHBvaW50fS9ncm91cHMvJHtvcHRpb25zLmdyb3VwSWR9L2NpZHNgLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgYWRkVG9Hcm91cDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWRkaW5nIENJRHMgdG8gZ3JvdXBcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2dyb3Vwcy91cGRhdGVHcm91cC50c1xudmFyIHVwZGF0ZUdyb3VwID0gYXN5bmMgKGNvbmZpZywgb3B0aW9ucykgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgbmFtZTogb3B0aW9ucy5uYW1lXG4gIH0pO1xuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay91cGRhdGVHcm91cFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L2dyb3Vwcy8ke29wdGlvbnMuZ3JvdXBJZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgdXBkYXRlR3JvdXA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSB1cGRhdGluZyBncm91cFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvZ3JvdXBzL3JlbW92ZUZyb21Hcm91cC50c1xudmFyIHJlbW92ZUZyb21Hcm91cCA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9yZW1vdmVGcm9tR3JvdXBcIlxuICAgIH07XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBjaWRzOiBvcHRpb25zLmNpZHNcbiAgfSk7XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vZ3JvdXBzLyR7b3B0aW9ucy5ncm91cElkfS9jaWRzYCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGRhdGFcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyByZW1vdmVGcm9tR3JvdXA6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVtb3ZpbmcgQ0lEcyBmcm9tIGEgZ3JvdXBcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2dyb3Vwcy9kZWxldGVHcm91cC50c1xudmFyIGRlbGV0ZUdyb3VwID0gYXN5bmMgKGNvbmZpZywgb3B0aW9ucykgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBTb3VyY2U6IFwic2RrL2RlbGV0ZUdyb3VwXCJcbiAgICB9O1xuICB9XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vZ3JvdXBzLyR7b3B0aW9ucy5ncm91cElkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGRlbGV0ZUdyb3VwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZGVsZXRpbmcgYSBncm91cFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvc2lnbmF0dXJlcy9hZGRTaWduYXR1cmUudHNcbnZhciBhZGRTaWduYXR1cmUgPSBhc3luYyAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBzaWduYXR1cmU6IG9wdGlvbnMuc2lnbmF0dXJlXG4gIH0pO1xuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9hZGRTaWduYXR1cmVcIlxuICAgIH07XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7ZW5kcG9pbnR9L3YzL2lwZnMvc2lnbmF0dXJlLyR7b3B0aW9ucy5jaWR9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogZGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgICBcIlVuYXV0aG9yaXplZCBzaWduaW5nLCB5b3UgbXVzdCBiZSB0aGUgb3JpZ2luYWwgb3duZXIgb2YgdGhlIGZpbGUgYW5kIGl0IG11c3Qgbm90IGhhdmUgYSBzaWduYXR1cmVcIixcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGFkZFNpZ25hdHVyZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWRkaW5nIHNpZ25hdHVyZSB0byBDSURcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL3NpZ25hdHVyZXMvZ2V0U2lnbmF0dXJlLnRzXG52YXIgZ2V0U2lnbmF0dXJlID0gYXN5bmMgKGNvbmZpZywgY2lkKSA9PiB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlBpbmF0YSBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7XG4gIH1cbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFNvdXJjZTogXCJzZGsvZ2V0U2lnbmF0dXJlXCJcbiAgICB9O1xuICB9XG4gIGxldCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkXCI7XG4gIGlmIChjb25maWcuZW5kcG9pbnRVcmwpIHtcbiAgICBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludFVybDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludH0vdjMvaXBmcy9zaWduYXR1cmUvJHtjaWR9YCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBnZXRTaWduYXR1cmU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHNpZ25hdHVyZSBmb3IgQ0lEXCJcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9zaWduYXR1cmVzL3JlbW92ZVNpZ25hdHVyZS50c1xudmFyIHJlbW92ZVNpZ25hdHVyZSA9IGFzeW5jIChjb25maWcsIGNpZCkgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBTb3VyY2U6IFwic2RrL3JlbW92ZVNpZ25hdHVyZVwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3YzL2lwZnMvc2lnbmF0dXJlLyR7Y2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBcIk9LXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGFkZFNpZ25hdHVyZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWRkaW5nIHNpZ25hdHVyZSB0byBDSURcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2dhdGV3YXkvYW5hbHl0aWNzVG9wVXNhZ2UudHNcbnZhciBhbmFseXRpY3NUb3BVc2FnZSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBpbmNsdWRlc0NvdW50OiBcImZhbHNlXCJcbiAgfSk7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2lkLFxuICAgICAgZ2F0ZXdheV9kb21haW4sXG4gICAgICBzdGFydF9kYXRlLFxuICAgICAgZW5kX2RhdGUsXG4gICAgICBmaWxlX25hbWUsXG4gICAgICB1c2VyX2FnZW50LFxuICAgICAgY291bnRyeSxcbiAgICAgIHJlZ2lvbixcbiAgICAgIHJlZmVyZXIsXG4gICAgICBsaW1pdCxcbiAgICAgIHNvcnRfb3JkZXIsXG4gICAgICBzb3J0X2J5LFxuICAgICAgYXR0cmlidXRlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGNpZClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJjaWRcIiwgY2lkKTtcbiAgICBpZiAoZ2F0ZXdheV9kb21haW4pXG4gICAgICBwYXJhbXMuYXBwZW5kKFwiZ2F0ZXdheV9kb21haW5cIiwgZ2F0ZXdheV9kb21haW4pO1xuICAgIGlmIChzdGFydF9kYXRlKVxuICAgICAgcGFyYW1zLmFwcGVuZChcInN0YXJ0X2RhdGVcIiwgc3RhcnRfZGF0ZSk7XG4gICAgaWYgKGVuZF9kYXRlKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImVuZF9kYXRlXCIsIGVuZF9kYXRlKTtcbiAgICBpZiAoZmlsZV9uYW1lKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImZpbGVfbmFtZVwiLCBmaWxlX25hbWUpO1xuICAgIGlmICh1c2VyX2FnZW50KVxuICAgICAgcGFyYW1zLmFwcGVuZChcInVzZXJfYWdlbnRcIiwgdXNlcl9hZ2VudC50b1N0cmluZygpKTtcbiAgICBpZiAoY291bnRyeSlcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJjb3VudHJ5XCIsIGNvdW50cnkudG9TdHJpbmcoKSk7XG4gICAgaWYgKHJlZ2lvbilcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWdpb25cIiwgcmVnaW9uKTtcbiAgICBpZiAocmVmZXJlcilcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVyXCIsIHJlZmVyZXIudG9TdHJpbmcoKSk7XG4gICAgaWYgKGxpbWl0KVxuICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgIGlmIChzb3J0X29yZGVyKVxuICAgICAgcGFyYW1zLmFwcGVuZChcInNvcnRfb3JkZXJcIiwgc29ydF9vcmRlcik7XG4gICAgaWYgKHNvcnRfYnkpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9ieVwiLCBzb3J0X2J5KTtcbiAgICBpZiAoYXR0cmlidXRlKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImJ5XCIsIGF0dHJpYnV0ZSk7XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIGNvbnN0IHVybCA9IGAke2VuZHBvaW50fS92My9pcGZzL2dhdGV3YXlfYW5hbHl0aWNzX3RvcD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gIHRyeSB7XG4gICAgbGV0IGhlYWRlcnM7XG4gICAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzID0ge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgICBTb3VyY2U6IFwic2RrL2FuYWx5dGljc1RvcFVzYWdlXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlcXVlc3Qub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDEgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIGNvbnN0IHJlc0RhdGEgPSByZXMuZGF0YTtcbiAgICByZXR1cm4gcmVzRGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGFuYXl0aWNzIHVzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIGdhdGV3YXkgdXNhZ2VcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2dhdGV3YXkvYW5hbHl0aWNzRGF0ZUludGVydmFsLnRzXG52YXIgYW5hbHl0aWNzRGF0ZUludGVydmFsID0gYXN5bmMgKGNvbmZpZywgb3B0aW9ucykgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaWQsXG4gICAgICBnYXRld2F5X2RvbWFpbixcbiAgICAgIHN0YXJ0X2RhdGUsXG4gICAgICBlbmRfZGF0ZSxcbiAgICAgIGZpbGVfbmFtZSxcbiAgICAgIHVzZXJfYWdlbnQsXG4gICAgICBjb3VudHJ5LFxuICAgICAgcmVnaW9uLFxuICAgICAgcmVmZXJlcixcbiAgICAgIGxpbWl0LFxuICAgICAgc29ydF9vcmRlcixcbiAgICAgIGRhdGVfaW50ZXJ2YWwsXG4gICAgICBzb3J0X2J5XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGNpZClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJjaWRcIiwgY2lkKTtcbiAgICBpZiAoZ2F0ZXdheV9kb21haW4pXG4gICAgICBwYXJhbXMuYXBwZW5kKFwiZ2F0ZXdheV9kb21haW5cIiwgZ2F0ZXdheV9kb21haW4pO1xuICAgIGlmIChzdGFydF9kYXRlKVxuICAgICAgcGFyYW1zLmFwcGVuZChcInN0YXJ0X2RhdGVcIiwgc3RhcnRfZGF0ZSk7XG4gICAgaWYgKGVuZF9kYXRlKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImVuZF9kYXRlXCIsIGVuZF9kYXRlKTtcbiAgICBpZiAoZmlsZV9uYW1lKVxuICAgICAgcGFyYW1zLmFwcGVuZChcImZpbGVfbmFtZVwiLCBmaWxlX25hbWUpO1xuICAgIGlmICh1c2VyX2FnZW50KVxuICAgICAgcGFyYW1zLmFwcGVuZChcInVzZXJfYWdlbnRcIiwgdXNlcl9hZ2VudC50b1N0cmluZygpKTtcbiAgICBpZiAoY291bnRyeSlcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJjb3VudHJ5XCIsIGNvdW50cnkudG9TdHJpbmcoKSk7XG4gICAgaWYgKHJlZ2lvbilcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWdpb25cIiwgcmVnaW9uKTtcbiAgICBpZiAocmVmZXJlcilcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVyXCIsIHJlZmVyZXIudG9TdHJpbmcoKSk7XG4gICAgaWYgKGxpbWl0KVxuICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgIGlmIChzb3J0X29yZGVyKVxuICAgICAgcGFyYW1zLmFwcGVuZChcInNvcnRfb3JkZXJcIiwgc29ydF9vcmRlcik7XG4gICAgaWYgKHNvcnRfYnkpXG4gICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9ieVwiLCBzb3J0X2J5KTtcbiAgICBpZiAoZGF0ZV9pbnRlcnZhbClcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJieVwiLCBkYXRlX2ludGVydmFsKTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnR9L3YzL2lwZnMvZ2F0ZXdheV9hbmFseXRpY3NfdGltZV9zZXJpZXM/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICB0cnkge1xuICAgIGxldCBoZWFkZXJzO1xuICAgIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgICAgU291cmNlOiBcInNkay9hbmFseXRpY3NEYXRlSW50ZXJ2YWxcIlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICBgSFRUUCBlcnJvcjogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgY29uc3QgcmVzRGF0YSA9IHJlcy5kYXRhO1xuICAgIHJldHVybiByZXNEYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgYW5heXRpY3MgdXNhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgZ2F0ZXdheSB1c2FnZVwiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvZ2F0ZXdheS9zd2FwQ2lkLnRzXG52YXIgc3dhcENpZCA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIHN3YXBDaWQ6IG9wdGlvbnMuc3dhcENpZFxuICB9KTtcbiAgbGV0IGhlYWRlcnM7XG4gIGlmIChjb25maWcuY3VzdG9tSGVhZGVycyAmJiBPYmplY3Qua2V5cyhjb25maWcuY3VzdG9tSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgIGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5jdXN0b21IZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb25maWcucGluYXRhSnd0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFNvdXJjZTogXCJzZGsvc3dhcENpZFwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3YzL2lwZnMvc3dhcC8ke29wdGlvbnMuY2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgICBcIlVuYXV0aG9yaXplZCBDSUQgU3dhcFwiLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgICAgIFwiQ0lEIG5vdCBwaW5uZWQgdG8gYWNjb3VudFwiLFxuICAgICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgIGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgYEhUVFAgZXJyb3I6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgIHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIGNvbnN0IHJlc0RhdGEgPSByZXMuZGF0YTtcbiAgICByZXR1cm4gcmVzRGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaW5hdGFFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgQ0lEIFN3YXA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBzd2FwcGluZyBDSURcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2dhdGV3YXkvc3dhcEhpc3RvcnkudHNcbnZhciBzd2FwSGlzdG9yeSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiUGluYXRhIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTtcbiAgfVxuICBsZXQgaGVhZGVycztcbiAgaWYgKGNvbmZpZy5jdXN0b21IZWFkZXJzICYmIE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgaGVhZGVycyA9IHsgLi4uY29uZmlnLmN1c3RvbUhlYWRlcnMgfTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5waW5hdGFKd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgU291cmNlOiBcInNkay9zd2FwSGlzdG9yeVwiXG4gICAgfTtcbiAgfVxuICBsZXQgZW5kcG9pbnQgPSBcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZFwiO1xuICBpZiAoY29uZmlnLmVuZHBvaW50VXJsKSB7XG4gICAgZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnRVcmw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtlbmRwb2ludH0vdjMvaXBmcy9zd2FwLyR7b3B0aW9ucy5jaWR9P2RvbWFpbj0ke29wdGlvbnMuZG9tYWlufWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFyZXF1ZXN0Lm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAxIHx8IHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGF9YCxcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgICBcIkNJRCBkb2VzIG5vdCBoYXZlIGhpc3RvcnlcIixcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBjb25zdCByZXNEYXRhID0gcmVzLmRhdGE7XG4gICAgcmV0dXJuIHJlc0RhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGluYXRhRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKGBFcnJvciBmZXRjaGluZyBzd2FwIGhpc3Rvcnk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBpbmF0YUVycm9yKFxuICAgICAgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHN3YXAgaGlzdG9yeVwiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvZ2F0ZXdheS9kZWxldGVTd2FwLnRzXG52YXIgZGVsZXRlU3dhcCA9IGFzeW5jIChjb25maWcsIGNpZCkgPT4ge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJQaW5hdGEgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nXCIpO1xuICB9XG4gIGxldCBoZWFkZXJzO1xuICBpZiAoY29uZmlnLmN1c3RvbUhlYWRlcnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmN1c3RvbUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkZXJzID0geyAuLi5jb25maWcuY3VzdG9tSGVhZGVycyB9O1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y29uZmlnLnBpbmF0YUp3dH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBTb3VyY2U6IFwic2RrL2RlbGV0ZVN3YXBcIlxuICAgIH07XG4gIH1cbiAgbGV0IGVuZHBvaW50ID0gXCJodHRwczovL2FwaS5waW5hdGEuY2xvdWRcIjtcbiAgaWYgKGNvbmZpZy5lbmRwb2ludFVybCkge1xuICAgIGVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50VXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKGAke2VuZHBvaW50fS92My9pcGZzL3N3YXAvJHtjaWR9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVxdWVzdC5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMSB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhfWAsXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgUGluYXRhRXJyb3IoXG4gICAgICAgICAgXCJVbmF1dGhvcml6ZWQgQ0lEIFN3YXAgRGVsZXRpb25cIixcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcbiAgICAgICAgICBcIkNJRCBub3QgcGlubmVkIHRvIGFjY291bnRcIixcbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBIVFRQIGVycm9yOiAke2Vycm9yRGF0YX1gLFxuICAgICAgICByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdC5zdGF0dXNUZXh0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFBpbmF0YUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBkZWxldGVTd2FwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQaW5hdGFFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZGVsZXRpbmcgc3dhcFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvcGluYXRhU0RLLnRzXG52YXIgZm9ybWF0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICBsZXQgZ2F0ZXdheSA9IGNvbmZpZz8ucGluYXRhR2F0ZXdheTtcbiAgaWYgKGNvbmZpZyAmJiBnYXRld2F5KSB7XG4gICAgaWYgKGdhdGV3YXkgJiYgIWdhdGV3YXkuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICBnYXRld2F5ID0gYGh0dHBzOi8vJHtnYXRld2F5fWA7XG4gICAgfVxuICAgIGNvbmZpZy5waW5hdGFHYXRld2F5ID0gZ2F0ZXdheTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcbnZhciBQaW5hdGFTREsgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gZm9ybWF0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy51cGxvYWQgPSBuZXcgVXBsb2FkKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmdhdGV3YXlzID0gbmV3IEdhdGV3YXlzKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLnVzYWdlID0gbmV3IFVzYWdlKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmtleXMgPSBuZXcgS2V5cyh0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5ncm91cHMgPSBuZXcgR3JvdXBzKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBuZXcgU2lnbmF0dXJlcyh0aGlzLmNvbmZpZyk7XG4gIH1cbiAgc2V0TmV3SGVhZGVycyhoZWFkZXJzKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB7IHBpbmF0YUp3dDogXCJcIiwgY3VzdG9tSGVhZGVyczoge30gfTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcuY3VzdG9tSGVhZGVycyA9IHsgLi4udGhpcy5jb25maWcuY3VzdG9tSGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMudXBsb2FkLnVwZGF0ZUNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5nYXRld2F5cy51cGRhdGVDb25maWcodGhpcy5jb25maWcpO1xuICAgIHRoaXMudXNhZ2UudXBkYXRlQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmtleXMudXBkYXRlQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmdyb3Vwcy51cGRhdGVDb25maWcodGhpcy5jb25maWcpO1xuICAgIHRoaXMuc2lnbmF0dXJlcy51cGRhdGVDb25maWcodGhpcy5jb25maWcpO1xuICB9XG4gIHRlc3RBdXRoZW50aWNhdGlvbigpIHtcbiAgICByZXR1cm4gdGVzdEF1dGhlbnRpY2F0aW9uKHRoaXMuY29uZmlnKTtcbiAgfVxuICB1bnBpbihmaWxlcykge1xuICAgIHJldHVybiB1bnBpbkZpbGUodGhpcy5jb25maWcsIGZpbGVzKTtcbiAgfVxuICBsaXN0RmlsZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJGaWxlcyh0aGlzLmNvbmZpZyk7XG4gIH1cbiAgdXBkYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgIHJldHVybiB1cGRhdGVNZXRhZGF0YSh0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG4gIH1cbiAgcGluSm9icygpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlclBpbkpvYnModGhpcy5jb25maWcpO1xuICB9XG59O1xudmFyIFVwbG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgdXBsb2FkRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnVwbG9hZEZ1bmN0aW9uID0gdXBsb2FkRnVuY3Rpb247XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICB9XG4gIGFkZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGtleShqd3QpIHtcbiAgICB0aGlzLmtleXMgPSBqd3Q7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2lkVmVyc2lvbih2KSB7XG4gICAgdGhpcy52ZXJzaW9uID0gdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm91cChncm91cElkKSB7XG4gICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwZWVyQWRkcmVzcyhwZWVyQWRkcmVzc2VzKSB7XG4gICAgdGhpcy5wZWVyQWRkcmVzc2VzID0gcGVlckFkZHJlc3NlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuYXJnc1t0aGlzLmFyZ3MubGVuZ3RoIC0gMV0gfHwge307XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHtcbiAgICAgIG9wdGlvbnMubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlzKSB7XG4gICAgICBvcHRpb25zLmtleXMgPSB0aGlzLmtleXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyb3VwSWQpIHtcbiAgICAgIG9wdGlvbnMuZ3JvdXBJZCA9IHRoaXMuZ3JvdXBJZDtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyc2lvbikge1xuICAgICAgb3B0aW9ucy5jaWRWZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5wZWVyQWRkcmVzc2VzICYmIFwicGVlckFkZHJlc3Nlc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMucGVlckFkZHJlc3NlcyA9IHRoaXMucGVlckFkZHJlc3NlcztcbiAgICB9XG4gICAgdGhpcy5hcmdzW3RoaXMuYXJncy5sZW5ndGggLSAxXSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkRnVuY3Rpb24odGhpcy5jb25maWcsIC4uLnRoaXMuYXJncykudGhlbihcbiAgICAgIG9uZnVsZmlsbGVkLFxuICAgICAgb25yZWplY3RlZFxuICAgICk7XG4gIH1cbn07XG52YXIgVXBsb2FkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGZvcm1hdENvbmZpZyhjb25maWcpO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhuZXdDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IG5ld0NvbmZpZztcbiAgfVxuICBmaWxlKGZpbGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwbG9hZEJ1aWxkZXIodGhpcy5jb25maWcsIHVwbG9hZEZpbGUsIGZpbGUsIG9wdGlvbnMpO1xuICB9XG4gIGZpbGVBcnJheShmaWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBsb2FkQnVpbGRlcih0aGlzLmNvbmZpZywgdXBsb2FkRmlsZUFycmF5LCBmaWxlcywgb3B0aW9ucyk7XG4gIH1cbiAgYmFzZTY0KGJhc2U2NFN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBsb2FkQnVpbGRlcih0aGlzLmNvbmZpZywgdXBsb2FkQmFzZTY0LCBiYXNlNjRTdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwbG9hZEJ1aWxkZXIodGhpcy5jb25maWcsIHVwbG9hZFVybCwgdXJsLCBvcHRpb25zKTtcbiAgfVxuICBqc29uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwbG9hZEJ1aWxkZXIodGhpcy5jb25maWcsIHVwbG9hZEpzb24sIGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGNpZChjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwbG9hZEJ1aWxkZXIodGhpcy5jb25maWcsIHVwbG9hZENpZCwgY2lkLCBvcHRpb25zKTtcbiAgfVxufTtcbnZhciBGaWx0ZXJGaWxlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgIC8vIHJhdGUgbGltaXQgdmFyc1xuICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IDA7XG4gICAgdGhpcy5NQVhfUkVRVUVTVFNfUEVSX01JTlVURSA9IDMwO1xuICAgIHRoaXMuTUlOVVRFX0lOX01TID0gNmU0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGNpZChjaWQpIHtcbiAgICB0aGlzLnF1ZXJ5LmNpZCA9IGNpZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwaW5TdGFydChkYXRlKSB7XG4gICAgdGhpcy5xdWVyeS5waW5TdGFydCA9IGRhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGluRW5kKGRhdGUpIHtcbiAgICB0aGlzLnF1ZXJ5LnBpbkVuZCA9IGRhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGluU2l6ZU1pbihzaXplKSB7XG4gICAgdGhpcy5xdWVyeS5waW5TaXplTWluID0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwaW5TaXplTWF4KHNpemUpIHtcbiAgICB0aGlzLnF1ZXJ5LnBpblNpemVNYXggPSBzaXplO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBhZ2VMaW1pdChsaW1pdCkge1xuICAgIHRoaXMucXVlcnkucGFnZUxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFnZU9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLnF1ZXJ5LnBhZ2VPZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5xdWVyeS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm91cChncm91cElkKSB7XG4gICAgdGhpcy5xdWVyeS5ncm91cElkID0gZ3JvdXBJZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBrZXlWYWx1ZShrZXksIHZhbHVlLCBvcGVyYXRvcikge1xuICAgIHRoaXMucXVlcnkua2V5ID0ga2V5O1xuICAgIHRoaXMucXVlcnkudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgIHRoaXMucXVlcnkub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhlbihvbmZ1bGZpbGxlZCkge1xuICAgIHJldHVybiBsaXN0RmlsZXModGhpcy5jb25maWcsIHRoaXMucXVlcnkpLnRoZW4ob25mdWxmaWxsZWQpO1xuICB9XG4gIC8vIHJhdGUgbGltaXQsIGhvcGVmdWxseSB0ZW1wb3Jhcnk/XG4gIGFzeW5jIHJhdGVMaW1pdCgpIHtcbiAgICB0aGlzLnJlcXVlc3RDb3VudCsrO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdENvdW50ID49IHRoaXMuTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUpIHtcbiAgICAgIGNvbnN0IHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0ID0gbm93IC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG4gICAgICBpZiAodGltZVBhc3NlZFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLk1JTlVURV9JTl9NUykge1xuICAgICAgICBjb25zdCBkZWxheVRpbWUgPSB0aGlzLk1JTlVURV9JTl9NUyAtIHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheVRpbWUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBoYXNNb3JlID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMucXVlcnkucGFnZUxpbWl0IHx8IDEwO1xuICAgIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJhdGVMaW1pdCgpO1xuICAgICAgdGhpcy5xdWVyeS5wYWdlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgdGhpcy5xdWVyeS5wYWdlTGltaXQgPSBsaW1pdDtcbiAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgbGlzdEZpbGVzKHRoaXMuY29uZmlnLCB0aGlzLnF1ZXJ5KTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBhbGwoKSB7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgdGhpcykge1xuICAgICAgYWxsSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbEl0ZW1zO1xuICB9XG59O1xudmFyIEdhdGV3YXlzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGZvcm1hdENvbmZpZyhjb25maWcpO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhuZXdDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IG5ld0NvbmZpZztcbiAgfVxuICBnZXQoY2lkKSB7XG4gICAgcmV0dXJuIGdldENpZCh0aGlzLmNvbmZpZywgY2lkKTtcbiAgfVxuICBjb252ZXJ0KHVybCkge1xuICAgIHJldHVybiBjb252ZXJ0SVBGU1VybCh0aGlzLmNvbmZpZywgdXJsKTtcbiAgfVxuICB0b3BVc2FnZUFuYWx5dGljcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUb3BHYXRld2F5QW5hbHl0aWNzQnVpbGRlcihcbiAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgb3B0aW9ucy5kb21haW4sXG4gICAgICBvcHRpb25zLnN0YXJ0LFxuICAgICAgb3B0aW9ucy5lbmQsXG4gICAgICBvcHRpb25zLnNvcnRCeSxcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlXG4gICAgKTtcbiAgfVxuICBkYXRlSW50ZXJ2YWxBbmFseXRpY3Mob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsR2F0ZXdheUFuYWx5dGljc0J1aWxkZXIoXG4gICAgICB0aGlzLmNvbmZpZyxcbiAgICAgIG9wdGlvbnMuZG9tYWluLFxuICAgICAgb3B0aW9ucy5zdGFydCxcbiAgICAgIG9wdGlvbnMuZW5kLFxuICAgICAgb3B0aW9ucy5pbnRlcnZhbFxuICAgICk7XG4gIH1cbiAgc3dhcENpZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN3YXBDaWQodGhpcy5jb25maWcsIG9wdGlvbnMpO1xuICB9XG4gIHN3YXBIaXN0b3J5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3dhcEhpc3RvcnkodGhpcy5jb25maWcsIG9wdGlvbnMpO1xuICB9XG4gIGRlbGV0ZVN3YXAoY2lkKSB7XG4gICAgcmV0dXJuIGRlbGV0ZVN3YXAodGhpcy5jb25maWcsIGNpZCk7XG4gIH1cbn07XG52YXIgRmlsdGVyUGluSm9icyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgIC8vIHJhdGUgbGltaXQgdmFyc1xuICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IDA7XG4gICAgdGhpcy5NQVhfUkVRVUVTVFNfUEVSX01JTlVURSA9IDMwO1xuICAgIHRoaXMuTUlOVVRFX0lOX01TID0gNmU0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGNpZChjaWQpIHtcbiAgICB0aGlzLnF1ZXJ5LmlwZnNfcGluX2hhc2ggPSBjaWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMucXVlcnkuc3RhdHVzID0gc3RhdHVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBhZ2VMaW1pdChsaW1pdCkge1xuICAgIHRoaXMucXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwYWdlT2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMucXVlcnkub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNvcnQoc29ydCkge1xuICAgIHRoaXMucXVlcnkuc29ydCA9IHNvcnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhlbihvbmZ1bGZpbGxlZCkge1xuICAgIHJldHVybiBwaW5Kb2JzKHRoaXMuY29uZmlnLCB0aGlzLnF1ZXJ5KS50aGVuKG9uZnVsZmlsbGVkKTtcbiAgfVxuICAvLyByYXRlIGxpbWl0LCBob3BlZnVsbHkgdGVtcG9yYXJ5P1xuICBhc3luYyByYXRlTGltaXQoKSB7XG4gICAgdGhpcy5yZXF1ZXN0Q291bnQrKztcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0aGlzLnJlcXVlc3RDb3VudCA+PSB0aGlzLk1BWF9SRVFVRVNUU19QRVJfTUlOVVRFKSB7XG4gICAgICBjb25zdCB0aW1lUGFzc2VkU2luY2VMYXN0UmVxdWVzdCA9IG5vdyAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xuICAgICAgaWYgKHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5NSU5VVEVfSU5fTVMpIHtcbiAgICAgICAgY29uc3QgZGVsYXlUaW1lID0gdGhpcy5NSU5VVEVfSU5fTVMgLSB0aW1lUGFzc2VkU2luY2VMYXN0UmVxdWVzdDtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlUaW1lKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG4gICAgfVxuICAgIHRoaXMubGFzdFJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaGFzTW9yZSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbGltaXQgPSB0aGlzLnF1ZXJ5LmxpbWl0IHx8IDEwO1xuICAgIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJhdGVMaW1pdCgpO1xuICAgICAgdGhpcy5xdWVyeS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB0aGlzLnF1ZXJ5LmxpbWl0ID0gbGltaXQ7XG4gICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHBpbkpvYnModGhpcy5jb25maWcsIHRoaXMucXVlcnkpO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGhhc01vcmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBpdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGFsbCgpIHtcbiAgICBjb25zdCBhbGxJdGVtcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiB0aGlzKSB7XG4gICAgICBhbGxJdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gYWxsSXRlbXM7XG4gIH1cbn07XG52YXIgVXNhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gZm9ybWF0Q29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gbmV3Q29uZmlnO1xuICB9XG4gIHBpbm5lZEZpbGVDb3VudCgpIHtcbiAgICByZXR1cm4gcGlubmVkRmlsZUNvdW50KHRoaXMuY29uZmlnKTtcbiAgfVxuICB0b3RhbFN0b3JhZ2VTaXplKCkge1xuICAgIHJldHVybiB0b3RhbFN0b3JhZ2VVc2FnZSh0aGlzLmNvbmZpZyk7XG4gIH1cbn07XG52YXIgS2V5cyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBmb3JtYXRDb25maWcoY29uZmlnKTtcbiAgfVxuICB1cGRhdGVDb25maWcobmV3Q29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBuZXdDb25maWc7XG4gIH1cbiAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlS2V5KHRoaXMuY29uZmlnLCBvcHRpb25zKTtcbiAgfVxuICBsaXN0KCkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyS2V5cyh0aGlzLmNvbmZpZyk7XG4gIH1cbiAgcmV2b2tlKGtleXMpIHtcbiAgICByZXR1cm4gcmV2b2tlS2V5cyh0aGlzLmNvbmZpZywga2V5cyk7XG4gIH1cbn07XG52YXIgRmlsdGVyS2V5cyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgIC8vIHJhdGUgbGltaXQgdmFyc1xuICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IDA7XG4gICAgdGhpcy5NQVhfUkVRVUVTVFNfUEVSX01JTlVURSA9IDMwO1xuICAgIHRoaXMuTUlOVVRFX0lOX01TID0gNmU0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLnF1ZXJ5Lm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXZva2VkKHJldm9rZWQpIHtcbiAgICB0aGlzLnF1ZXJ5LnJldm9rZWQgPSByZXZva2VkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbWl0ZWRVc2UobGltaXRlZFVzZSkge1xuICAgIHRoaXMucXVlcnkubGltaXRlZFVzZSA9IGxpbWl0ZWRVc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXhoYXVzdGVkKGV4aGF1c3RlZCkge1xuICAgIHRoaXMucXVlcnkuZXhoYXVzdGVkID0gZXhoYXVzdGVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5hbWUobmFtZSkge1xuICAgIHRoaXMucXVlcnkubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhlbihvbmZ1bGZpbGxlZCkge1xuICAgIHJldHVybiBsaXN0S2V5cyh0aGlzLmNvbmZpZywgdGhpcy5xdWVyeSkudGhlbihvbmZ1bGZpbGxlZCk7XG4gIH1cbiAgLy8gcmF0ZSBsaW1pdCwgaG9wZWZ1bGx5IHRlbXBvcmFyeT9cbiAgYXN5bmMgcmF0ZUxpbWl0KCkge1xuICAgIHRoaXMucmVxdWVzdENvdW50Kys7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0Q291bnQgPj0gdGhpcy5NQVhfUkVRVUVTVFNfUEVSX01JTlVURSkge1xuICAgICAgY29uc3QgdGltZVBhc3NlZFNpbmNlTGFzdFJlcXVlc3QgPSBub3cgLSB0aGlzLmxhc3RSZXF1ZXN0VGltZTtcbiAgICAgIGlmICh0aW1lUGFzc2VkU2luY2VMYXN0UmVxdWVzdCA8IHRoaXMuTUlOVVRFX0lOX01TKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5VGltZSA9IHRoaXMuTUlOVVRFX0lOX01TIC0gdGltZVBhc3NlZFNpbmNlTGFzdFJlcXVlc3Q7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5VGltZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IGhhc01vcmUgPSB0cnVlO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJhdGVMaW1pdCgpO1xuICAgICAgdGhpcy5xdWVyeS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGxpc3RLZXlzKHRoaXMuY29uZmlnLCB0aGlzLnF1ZXJ5KTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBhbGwoKSB7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgdGhpcykge1xuICAgICAgYWxsSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbEl0ZW1zO1xuICB9XG59O1xudmFyIEdyb3VwcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBmb3JtYXRDb25maWcoY29uZmlnKTtcbiAgfVxuICB1cGRhdGVDb25maWcobmV3Q29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBuZXdDb25maWc7XG4gIH1cbiAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlR3JvdXAodGhpcy5jb25maWcsIG9wdGlvbnMpO1xuICB9XG4gIGxpc3QoKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJHcm91cHModGhpcy5jb25maWcpO1xuICB9XG4gIGdldChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEdyb3VwKHRoaXMuY29uZmlnLCBvcHRpb25zKTtcbiAgfVxuICBhZGRDaWRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWRkVG9Hcm91cCh0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG4gIH1cbiAgcmVtb3ZlQ2lkcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlbW92ZUZyb21Hcm91cCh0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG4gIH1cbiAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXBkYXRlR3JvdXAodGhpcy5jb25maWcsIG9wdGlvbnMpO1xuICB9XG4gIGRlbGV0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlbGV0ZUdyb3VwKHRoaXMuY29uZmlnLCBvcHRpb25zKTtcbiAgfVxufTtcbnZhciBGaWx0ZXJHcm91cHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAvLyByYXRlIGxpbWl0IHZhcnNcbiAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSAwO1xuICAgIHRoaXMuTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUgPSAzMDtcbiAgICB0aGlzLk1JTlVURV9JTl9NUyA9IDZlNDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5xdWVyeS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmFtZShuYW1lQ29udGFpbnMpIHtcbiAgICB0aGlzLnF1ZXJ5Lm5hbWVDb250YWlucyA9IG5hbWVDb250YWlucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaW1pdChsaW1pdCkge1xuICAgIHRoaXMucXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGVuKG9uZnVsZmlsbGVkKSB7XG4gICAgcmV0dXJuIGxpc3RHcm91cHModGhpcy5jb25maWcsIHRoaXMucXVlcnkpLnRoZW4ob25mdWxmaWxsZWQpO1xuICB9XG4gIC8vIHJhdGUgbGltaXQsIGhvcGVmdWxseSB0ZW1wb3Jhcnk/XG4gIGFzeW5jIHJhdGVMaW1pdCgpIHtcbiAgICB0aGlzLnJlcXVlc3RDb3VudCsrO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdENvdW50ID49IHRoaXMuTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUpIHtcbiAgICAgIGNvbnN0IHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0ID0gbm93IC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG4gICAgICBpZiAodGltZVBhc3NlZFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLk1JTlVURV9JTl9NUykge1xuICAgICAgICBjb25zdCBkZWxheVRpbWUgPSB0aGlzLk1JTlVURV9JTl9NUyAtIHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheVRpbWUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBoYXNNb3JlID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAoaGFzTW9yZSkge1xuICAgICAgYXdhaXQgdGhpcy5yYXRlTGltaXQoKTtcbiAgICAgIHRoaXMucXVlcnkub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBsaXN0R3JvdXBzKHRoaXMuY29uZmlnLCB0aGlzLnF1ZXJ5KTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBhbGwoKSB7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgdGhpcykge1xuICAgICAgYWxsSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbEl0ZW1zO1xuICB9XG59O1xudmFyIFNpZ25hdHVyZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gZm9ybWF0Q29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gbmV3Q29uZmlnO1xuICB9XG4gIGFkZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZFNpZ25hdHVyZSh0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0KGNpZCkge1xuICAgIHJldHVybiBnZXRTaWduYXR1cmUodGhpcy5jb25maWcsIGNpZCk7XG4gIH1cbiAgZGVsZXRlKGNpZCkge1xuICAgIHJldHVybiByZW1vdmVTaWduYXR1cmUodGhpcy5jb25maWcsIGNpZCk7XG4gIH1cbn07XG52YXIgR2F0ZXdheUFuYWx5dGljc0J1aWxkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgcXVlcnkpIHtcbiAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSAwO1xuICAgIHRoaXMuTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUgPSAzMDtcbiAgICB0aGlzLk1JTlVURV9JTl9NUyA9IDZlNDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cbiAgY2lkKGNpZCkge1xuICAgIHRoaXMucXVlcnkuY2lkID0gY2lkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgdGhpcy5xdWVyeS5maWxlX25hbWUgPSBmaWxlTmFtZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1c2VyQWdlbnQodXNlckFnZW50KSB7XG4gICAgdGhpcy5xdWVyeS51c2VyX2FnZW50ID0gdXNlckFnZW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvdW50cnkoY291bnRyeSkge1xuICAgIHRoaXMucXVlcnkuY291bnRyeSA9IGNvdW50cnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVnaW9uKHJlZ2lvbikge1xuICAgIHRoaXMucXVlcnkucmVnaW9uID0gcmVnaW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZmVyZXIocmVmZXJlcikge1xuICAgIHRoaXMucXVlcnkucmVmZXJlciA9IHJlZmVyZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLnF1ZXJ5LmxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc29ydChvcmRlcikge1xuICAgIHRoaXMucXVlcnkuc29ydF9vcmRlciA9IG9yZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIHJhdGVMaW1pdCgpIHtcbiAgICB0aGlzLnJlcXVlc3RDb3VudCsrO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdENvdW50ID49IHRoaXMuTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUpIHtcbiAgICAgIGNvbnN0IHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0ID0gbm93IC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG4gICAgICBpZiAodGltZVBhc3NlZFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLk1JTlVURV9JTl9NUykge1xuICAgICAgICBjb25zdCBkZWxheVRpbWUgPSB0aGlzLk1JTlVURV9JTl9NUyAtIHRpbWVQYXNzZWRTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheVRpbWUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIGFzeW5jIGdldEFuYWx5dGljcygpIHtcbiAgICBhd2FpdCB0aGlzLnJhdGVMaW1pdCgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldEFuYWx5dGljcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBkZXJpdmVkIGNsYXNzXCIpO1xuICB9XG4gIHRoZW4ob25mdWxmaWxsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbmFseXRpY3MoKS50aGVuKG9uZnVsZmlsbGVkKTtcbiAgfVxufTtcbnZhciBUb3BHYXRld2F5QW5hbHl0aWNzQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgR2F0ZXdheUFuYWx5dGljc0J1aWxkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIGRvbWFpbiwgc3RhcnQsIGVuZCwgc29ydEJ5LCBhdHRyaWJ1dGUpIHtcbiAgICBzdXBlcihjb25maWcsIHtcbiAgICAgIGdhdGV3YXlfZG9tYWluOiBkb21haW4sXG4gICAgICBzdGFydF9kYXRlOiBzdGFydCxcbiAgICAgIGVuZF9kYXRlOiBlbmQsXG4gICAgICBzb3J0X2J5OiBzb3J0QnksXG4gICAgICBhdHRyaWJ1dGVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRBbmFseXRpY3MoKSB7XG4gICAgcmV0dXJuIGFuYWx5dGljc1RvcFVzYWdlKHRoaXMuY29uZmlnLCB0aGlzLnF1ZXJ5KTtcbiAgfVxuICBhc3luYyBhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QW5hbHl0aWNzKCk7XG4gIH1cbn07XG52YXIgVGltZUludGVydmFsR2F0ZXdheUFuYWx5dGljc0J1aWxkZXIgPSBjbGFzcyBleHRlbmRzIEdhdGV3YXlBbmFseXRpY3NCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBkb21haW4sIHN0YXJ0LCBlbmQsIGRhdGVJbnRlcnZhbCkge1xuICAgIHN1cGVyKGNvbmZpZywge1xuICAgICAgZ2F0ZXdheV9kb21haW46IGRvbWFpbixcbiAgICAgIHN0YXJ0X2RhdGU6IHN0YXJ0LFxuICAgICAgZW5kX2RhdGU6IGVuZCxcbiAgICAgIGRhdGVfaW50ZXJ2YWw6IGRhdGVJbnRlcnZhbFxuICAgIH0pO1xuICB9XG4gIHNvcnRCeShzb3J0QnkpIHtcbiAgICB0aGlzLnF1ZXJ5LnNvcnRfYnkgPSBzb3J0Qnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgZ2V0QW5hbHl0aWNzKCkge1xuICAgIHJldHVybiBhbmFseXRpY3NEYXRlSW50ZXJ2YWwodGhpcy5jb25maWcsIHRoaXMucXVlcnkpO1xuICB9XG4gIGFzeW5jIGFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbmFseXRpY3MoKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFBpbmF0YVNES1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pinata/dist/index.mjs\n");

/***/ })

};
;